{
  "timestamp": "20250530_130841",
  "summary": {
    "total": 15,
    "passed": 5,
    "failed": 10,
    "success_rate": 33.33333333333333
  },
  "results": [
    {
      "command": "python manage.py check",
      "description": "Django System Checks",
      "returncode": 0,
      "execution_time": 1.0235183238983154,
      "stdout": "System check identified no issues (0 silenced).\n",
      "stderr": ""
    },
    {
      "command": "python manage.py makemigrations --dry-run --check",
      "description": "Database Migrations Check",
      "returncode": 0,
      "execution_time": 1.0049500465393066,
      "stdout": "No changes detected\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_productos_models.py -v --tb=short",
      "description": "Unit Tests - test_productos_models.py",
      "returncode": 0,
      "execution_time": 2.3353214263916016,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 28 items\n\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_allow_optional_temporada PASSED [  3%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_create_catalogo_with_valid_data PASSED [  7%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_default_to_active_and_not_offer PASSED [ 10%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_enforce_unique_nombre PASSED [ 14%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_handle_long_nombres PASSED [ 17%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_have_correct_string_representation PASSED [ 21%]\ntests/unit/test_productos_models.py::CatalogoModelTests::test_should_validate_date_ranges PASSED [ 25%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_create_producto_with_valid_data PASSED [ 28%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_default_values PASSED [ 32%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_enforce_unique_codigo PASSED [ 35%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_handle_catalogo_deletion_gracefully PASSED [ 39%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_handle_optional_catalogo PASSED [ 42%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_handle_user_references PASSED [ 46%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_have_correct_string_representation PASSED [ 50%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_protect_against_proveedor_deletion PASSED [ 53%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_protect_against_tienda_deletion PASSED [ 57%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_validate_decimal_precision PASSED [ 60%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_validate_field_lengths PASSED [ 64%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_validate_positive_stock_minimo PASSED [ 67%]\ntests/unit/test_productos_models.py::ProductoModelTests::test_should_validate_required_fields PASSED [ 71%]\ntests/unit/test_productos_models.py::ProductoBusinessLogicTests::test_should_calculate_markup_correctly PASSED [ 75%]\ntests/unit/test_productos_models.py::ProductoBusinessLogicTests::test_should_handle_inventory_warnings PASSED [ 78%]\ntests/unit/test_productos_models.py::ProductoBusinessLogicTests::test_should_identify_productos_en_oferta PASSED [ 82%]\ntests/unit/test_productos_models.py::ProductoBusinessLogicTests::test_should_validate_pricing_logic PASSED [ 85%]\ntests/unit/test_productos_models.py::ProductosCatalogoIntegrationTests::test_should_calculate_catalogo_statistics PASSED [ 89%]\ntests/unit/test_productos_models.py::ProductosCatalogoIntegrationTests::test_should_filter_productos_by_catalogo_status PASSED [ 92%]\ntests/unit/test_productos_models.py::ProductosCatalogoIntegrationTests::test_should_handle_seasonal_catalogs PASSED [ 96%]\ntests/unit/test_productos_models.py::ProductosCatalogoIntegrationTests::test_should_manage_catalogo_productos_relationship PASSED [100%]\n\n============================== warnings summary ===============================\ntests/unit/test_productos_models.py: 28 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: AdminUserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the AdminUserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_productos_models.py: 127 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n====================== 28 passed, 155 warnings in 0.53s =======================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_clientes_models.py -v --tb=short",
      "description": "Unit Tests - test_clientes_models.py",
      "returncode": 0,
      "execution_time": 2.2989208698272705,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 36 items\n\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_allow_negative_saldo_a_favor_for_debt_tracking PASSED [  2%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_allow_optional_fields_when_creating_cliente PASSED [  5%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_create_cliente_with_required_fields_when_valid_data_provided PASSED [  8%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_enforce_positive_max_return_days_when_creating PASSED [ 11%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_enforce_positive_puntos_lealtad_when_creating PASSED [ 13%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_handle_audit_fields_when_created_by_user PASSED [ 16%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_handle_user_relationship_correctly_when_set PASSED [ 19%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 22%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_protect_tienda_when_cliente_exists PASSED [ 25%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_set_null_when_user_deleted PASSED [ 27%]\ntests/unit/test_clientes_models.py::ClienteModelTestCase::test_should_validate_decimal_precision_when_creating PASSED [ 30%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_allow_created_by_field_when_user_provided PASSED [ 33%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_cascade_delete_when_cliente_deleted PASSED [ 36%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_create_anticipo_with_required_fields_when_valid_data_provided PASSED [ 38%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_handle_multiple_anticipos_per_cliente_when_different_dates PASSED [ 41%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 44%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_relate_to_cliente_correctly_through_foreign_key PASSED [ 47%]\ntests/unit/test_clientes_models.py::AnticipoModelTestCase::test_should_validate_positive_monto_when_creating PASSED [ 50%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_cascade_delete_when_cliente_deleted PASSED [ 52%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_create_descuento_with_required_fields_when_valid_data_provided PASSED [ 55%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_handle_audit_fields_correctly_when_user_provided PASSED [ 58%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_handle_multiple_descuentos_per_cliente_different_months PASSED [ 61%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 63%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_store_monto_acumulado_mes_anterior_when_provided PASSED [ 66%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_validate_mes_vigente_format_when_creating PASSED [ 69%]\ntests/unit/test_clientes_models.py::DescuentoClienteModelTestCase::test_should_validate_porcentaje_precision_when_creating PASSED [ 72%]\ntests/unit/test_clientes_models.py::ReglaProgramaLealtadModelTestCase::test_should_allow_inactive_reglas_when_activo_false PASSED [ 75%]\ntests/unit/test_clientes_models.py::ReglaProgramaLealtadModelTestCase::test_should_create_regla_with_required_fields_when_valid_data_provided PASSED [ 77%]\ntests/unit/test_clientes_models.py::ReglaProgramaLealtadModelTestCase::test_should_enforce_positive_puntos_otorgados_when_creating PASSED [ 80%]\ntests/unit/test_clientes_models.py::ReglaProgramaLealtadModelTestCase::test_should_enforce_unique_monto_compra_when_creating_duplicate PASSED [ 83%]\ntests/unit/test_clientes_models.py::ReglaProgramaLealtadModelTestCase::test_should_handle_multiple_reglas_different_montos_when_creating PASSED [ 86%]\ntests/unit/test_clientes_models.py::ClienteBusinessLogicTestCase::test_should_calculate_cliente_lealtad_points_correctly_when_compras_made PASSED [ 88%]\ntests/unit/test_clientes_models.py::ClienteBusinessLogicTestCase::test_should_handle_cliente_user_integration_when_distribuidora_access_needed PASSED [ 91%]\ntests/unit/test_clientes_models.py::ClienteBusinessLogicTestCase::test_should_handle_descuento_progression_correctly_when_months_change PASSED [ 94%]\ntests/unit/test_clientes_models.py::ClienteBusinessLogicTestCase::test_should_manage_cliente_saldo_transactions_correctly_when_operations_performed PASSED [ 97%]\ntests/unit/test_clientes_models.py::ClienteBusinessLogicTestCase::test_should_validate_cliente_credit_limits_when_business_rules_applied PASSED [100%]\n\n============================== warnings summary ===============================\ntests/unit/test_clientes_models.py: 76 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n======================= 36 passed, 76 warnings in 0.47s =======================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_descuentos_models.py -v --tb=short",
      "description": "Unit Tests - test_descuentos_models.py",
      "returncode": 0,
      "execution_time": 2.122706890106201,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 18 items\n\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_create_tabulador_with_required_fields PASSED [  5%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_handle_large_currency_amounts PASSED [ 11%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_handle_negative_values PASSED [ 16%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_handle_precise_percentage_values PASSED [ 22%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_handle_zero_ranges PASSED [ 27%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_return_formatted_string_representation PASSED [ 33%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_support_fractional_currency_amounts PASSED [ 38%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoModel::test_should_validate_decimal_precision PASSED [ 44%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoBusinessLogic::test_should_create_progressive_discount_structure PASSED [ 50%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoBusinessLogic::test_should_handle_gap_ranges PASSED [ 55%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoBusinessLogic::test_should_handle_overlapping_ranges PASSED [ 61%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoBusinessLogic::test_should_simulate_discount_calculation_logic PASSED [ 66%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoBusinessLogic::test_should_support_volume_discount_tiers PASSED [ 72%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoIntegration::test_should_handle_seasonal_discount_adjustments PASSED [ 77%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoIntegration::test_should_support_complex_discount_scenarios PASSED [ 83%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoIntegration::test_should_support_discount_combination_rules PASSED [ 88%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoIntegration::test_should_support_discount_queries PASSED [ 94%]\ntests/unit/test_descuentos_models.py::TestTabuladorDescuentoIntegration::test_should_validate_business_rules PASSED [100%]\n\n============================== warnings summary ===============================\ntests/unit/test_descuentos_models.py: 18 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: AdminUserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the AdminUserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_descuentos_models.py: 36 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n======================= 18 passed, 54 warnings in 0.33s =======================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_administracion_models.py -v --tb=short",
      "description": "Unit Tests - test_administracion_models.py",
      "returncode": 1,
      "execution_time": 2.836299419403076,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 27 items\n\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_allow_null_usuario_for_system_actions PASSED [  3%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_auto_set_fecha_on_creation PASSED [  7%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_create_log_auditoria_with_valid_data PASSED [ 11%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_handle_long_user_agent_strings PASSED [ 14%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_handle_system_user_in_string_representation PASSED [ 18%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_have_correct_string_representation PASSED [ 22%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_order_by_fecha_desc_by_default PASSED [ 25%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_store_ipv4_and_ipv6_addresses PASSED [ 29%]\ntests/unit/test_administracion_models.py::LogAuditoriaModelTests::test_should_validate_accion_choices PASSED [ 33%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_allow_optional_tienda_asignada PASSED [ 37%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_create_perfil_usuario_with_valid_data FAILED [ 40%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_enforce_one_to_one_relationship_with_user PASSED [ 44%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_handle_cuenta_bloqueada_scenarios PASSED [ 48%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_have_correct_string_representation PASSED [ 51%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_track_ultimo_acceso PASSED [ 55%]\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_validate_telefono_format PASSED [ 59%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_allow_long_descriptions PASSED [ 62%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_auto_update_fecha_modificacion PASSED [ 66%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_create_configuracion_with_valid_data PASSED [ 70%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_enforce_unique_clave PASSED [ 74%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_handle_different_data_types PASSED [ 77%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_handle_null_modificado_por PASSED [ 81%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_have_correct_string_representation PASSED [ 85%]\ntests/unit/test_administracion_models.py::ConfiguracionSistemaModelTests::test_should_validate_tipo_dato_choices PASSED [ 88%]\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_create_complete_audit_trail PASSED [ 92%]\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_handle_user_deletion_gracefully PASSED [ 96%]\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_track_temporal_changes PASSED [100%]\n\n================================== FAILURES ===================================\n__ PerfilUsuarioModelTests.test_should_create_perfil_usuario_with_valid_data __\ntests\\unit\\test_administracion_models.py:137: in test_should_create_perfil_usuario_with_valid_data\n    perfil = PerfilUsuarioFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: PerfilUsuario() got unexpected keyword arguments: 'max_return_days'\n============================== warnings summary ===============================\ntests/unit/test_administracion_models.py: 27 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: AdminUserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the AdminUserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py: 88 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_handle_cuenta_bloqueada_scenarios\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField PerfilUsuario.fecha_bloqueo received a naive datetime (2025-05-30 13:07:56.703962) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_track_ultimo_acceso\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField PerfilUsuario.fecha_ultimo_acceso received a naive datetime (2025-05-29 16:30:00) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_track_temporal_changes\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField ConfiguracionSistema.fecha_modificacion received a naive datetime (2025-05-29 10:00:00) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_track_temporal_changes\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField ConfiguracionSistema.fecha_modificacion received a naive datetime (2025-05-29 12:00:00) while time zone support is active.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_create_perfil_usuario_with_valid_data\n================= 1 failed, 26 passed, 119 warnings in 0.95s ==================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_inventario_models.py -v --tb=short",
      "description": "Unit Tests - test_inventario_models.py",
      "returncode": 1,
      "execution_time": 2.7283618450164795,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 37 items\n\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_allow_negative_cantidad_actual_when_tracking_shortages PASSED [  2%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_allow_zero_cantidad_actual_when_out_of_stock PASSED [  5%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_create_inventario_with_required_fields_when_valid_data_provided PASSED [  8%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_enforce_unique_constraint_tienda_producto_when_duplicate_created PASSED [ 10%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_handle_audit_fields_correctly_when_user_provided PASSED [ 13%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_handle_multiple_inventarios_different_tiendas_same_producto PASSED [ 16%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 18%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_protect_producto_when_inventario_exists PASSED [ 21%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_protect_tienda_when_inventario_exists PASSED [ 24%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_relate_to_producto_correctly_through_foreign_key PASSED [ 27%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_relate_to_tienda_correctly_through_foreign_key PASSED [ 29%]\ntests/unit/test_inventario_models.py::InventarioModelTestCase::test_should_set_null_when_user_deleted PASSED [ 32%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_allow_same_tienda_origen_multiple_traspasos_when_different_destinos PASSED [ 35%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_allow_valid_estados_when_creating_traspaso PASSED [ 37%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_auto_set_fecha_when_created FAILED [ 40%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_create_traspaso_with_required_fields_when_valid_data_provided PASSED [ 43%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_handle_audit_fields_correctly_when_created_by_user PASSED [ 45%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 48%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_protect_tienda_destino_when_traspaso_exists PASSED [ 51%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_protect_tienda_origen_when_traspaso_exists PASSED [ 54%]\ntests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_relate_to_tiendas_correctly_through_foreign_keys PASSED [ 56%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_allow_same_producto_multiple_traspasos_when_different_transactions PASSED [ 59%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_cascade_delete_when_traspaso_deleted PASSED [ 62%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_create_traspaso_item_with_required_fields_when_valid_data_provided PASSED [ 64%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_enforce_positive_cantidad_when_creating FAILED [ 67%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_handle_multiple_items_per_traspaso_when_different_products PASSED [ 70%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 72%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_protect_producto_when_traspaso_item_exists PASSED [ 75%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_relate_to_producto_correctly_through_foreign_key PASSED [ 78%]\ntests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_relate_to_traspaso_correctly_through_foreign_key PASSED [ 81%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_calculate_total_inventory_across_stores_when_queried PASSED [ 83%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_handle_concurrent_inventory_operations_when_multiple_users PASSED [ 86%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_handle_inventory_transfers_correctly_when_traspaso_completed PASSED [ 89%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_handle_stock_alerts_when_below_minimum PASSED [ 91%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_prevent_negative_stock_when_business_rules_require PASSED [ 94%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_track_inventory_history_when_changes_made PASSED [ 97%]\ntests/unit/test_inventario_models.py::InventarioBusinessLogicTestCase::test_should_validate_stock_availability_when_creating_traspaso PASSED [100%]\n\n================================== FAILURES ===================================\n________ TraspasoModelTestCase.test_should_auto_set_fecha_when_created ________\ntests\\unit\\test_inventario_models.py:277: in test_should_auto_set_fecha_when_created\n    traspaso = Traspaso.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:663: in create\n    obj.save(force_insert=True, using=self.db)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1169: in _save_table\n    results = self._do_insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1210: in _do_insert\n    return manager._insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1864: in _insert\n    return query.get_compiler(using=using).execute_sql(returning_fields)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1881: in execute_sql\n    for sql, params in self.as_sql():\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1806: in as_sql\n    self.prepare_value(field, self.pre_save_val(field, obj))\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1727: in prepare_value\n    raise ValueError(\nE   ValueError: Failed to insert expression \"<MagicMock name='now().resolve_expression()' id='2856664441120'>\" on inventario.Traspaso.fecha. F() expressions can only be used to update, not to insert.\n_ TraspasoItemModelTestCase.test_should_enforce_positive_cantidad_when_creating _\ntests\\unit\\test_inventario_models.py:324: in test_should_enforce_positive_cantidad_when_creating\n    with self.assertRaises(IntegrityError):\nE   AssertionError: IntegrityError not raised\n============================== warnings summary ===============================\ntests/unit/test_inventario_models.py: 132 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_auto_set_fecha_when_created\nFAILED tests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_enforce_positive_cantidad_when_creating\n================= 2 failed, 35 passed, 132 warnings in 0.79s ==================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_caja_models.py -v --tb=short",
      "description": "Unit Tests - test_caja_models.py",
      "returncode": 1,
      "execution_time": 3.0499966144561768,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 39 items\n\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_allow_negative_values_when_handling_deficits PASSED [  2%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_allow_optional_fields_when_creating_caja PASSED [  5%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_create_caja_with_required_fields_when_valid_data_provided PASSED [  7%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_handle_audit_fields_correctly_when_user_provided PASSED [ 10%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 12%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_protect_tienda_when_caja_exists PASSED [ 15%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_relate_to_tienda_correctly_through_foreign_key PASSED [ 17%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_set_null_when_user_deleted PASSED [ 20%]\ntests/unit/test_caja_models.py::CajaModelTestCase::test_should_validate_decimal_precision_when_creating PASSED [ 23%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_cascade_delete_when_caja_deleted PASSED [ 25%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_create_nota_cargo_with_required_fields_when_valid_data_provided PASSED [ 28%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_handle_created_by_field_when_user_provided PASSED [ 30%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_handle_multiple_notas_per_caja_when_different_motivos PASSED [ 33%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 35%]\ntests/unit/test_caja_models.py::NotaCargoModelTestCase::test_should_relate_to_caja_correctly_through_foreign_key PASSED [ 38%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_allow_optional_fields_when_creating_transaccion PASSED [ 41%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_allow_valid_tipos_movimiento_when_creating PASSED [ 43%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_cascade_delete_when_caja_deleted PASSED [ 46%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_create_transaccion_with_required_fields_when_valid_data_provided PASSED [ 48%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 51%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_have_movimientocaja_alias_when_imported PASSED [ 53%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_have_tipo_property_alias_when_accessed PASSED [ 56%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_relate_to_caja_correctly_through_foreign_key PASSED [ 58%]\ntests/unit/test_caja_models.py::TransaccionCajaModelTestCase::test_should_set_null_when_related_objects_deleted PASSED [ 61%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_create_factura_with_required_fields_when_valid_data_provided PASSED [ 64%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_onetoone_relationship_with_pedido FAILED [ 66%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_unique_folio_when_creating_duplicate FAILED [ 69%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_handle_created_by_field_when_user_provided FAILED [ 71%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_have_correct_string_representation_when_created FAILED [ 74%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_protect_pedido_when_factura_exists FAILED [ 76%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_relate_to_pedido_correctly_through_onetoone FAILED [ 79%]\ntests/unit/test_caja_models.py::FacturaModelTestCase::test_should_validate_decimal_precision_when_creating_factura PASSED [ 82%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_calculate_saldo_final_correctly_when_movements_processed FAILED [ 84%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_handle_daily_cash_flow_correctly_when_multiple_operations PASSED [ 87%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_handle_factura_generation_workflow_when_pedido_completed FAILED [ 89%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_handle_nota_cargo_impact_on_cash_flow_when_created PASSED [ 92%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_prevent_duplicate_facturas_when_pedido_already_has_one FAILED [ 94%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_track_cash_movements_history_when_operations_performed PASSED [ 97%]\ntests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_validate_caja_closure_rules_when_closing_cash_box PASSED [100%]\n\n================================== FAILURES ===================================\n_ FacturaModelTestCase.test_should_enforce_onetoone_relationship_with_pedido __\ntests\\unit\\test_caja_models.py:445: in test_should_enforce_onetoone_relationship_with_pedido\n    FacturaFactory(pedido=self.pedido)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ FacturaModelTestCase.test_should_enforce_unique_folio_when_creating_duplicate _\ntests\\unit\\test_caja_models.py:428: in test_should_enforce_unique_folio_when_creating_duplicate\n    FacturaFactory(pedido=self.pedido, folio=folio)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ FacturaModelTestCase.test_should_handle_created_by_field_when_user_provided _\ntests\\unit\\test_caja_models.py:476: in test_should_handle_created_by_field_when_user_provided\n    factura = FacturaFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ FacturaModelTestCase.test_should_have_correct_string_representation_when_created _\ntests\\unit\\test_caja_models.py:416: in test_should_have_correct_string_representation_when_created\n    factura = FacturaFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_____ FacturaModelTestCase.test_should_protect_pedido_when_factura_exists _____\ntests\\unit\\test_caja_models.py:458: in test_should_protect_pedido_when_factura_exists\n    FacturaFactory(pedido=self.pedido)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ FacturaModelTestCase.test_should_relate_to_pedido_correctly_through_onetoone _\ntests\\unit\\test_caja_models.py:466: in test_should_relate_to_pedido_correctly_through_onetoone\n    factura = FacturaFactory(pedido=self.pedido)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ CajaBusinessLogicTestCase.test_should_calculate_saldo_final_correctly_when_movements_processed _\ntests\\unit\\test_caja_models.py:533: in test_should_calculate_saldo_final_correctly_when_movements_processed\n    ).aggregate(total=models.Sum('monto'))['total'] or Decimal('0')\nE   NameError: name 'models' is not defined\n_ CajaBusinessLogicTestCase.test_should_handle_factura_generation_workflow_when_pedido_completed _\ntests\\unit\\test_caja_models.py:654: in test_should_handle_factura_generation_workflow_when_pedido_completed\n    factura = FacturaFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n_ CajaBusinessLogicTestCase.test_should_prevent_duplicate_facturas_when_pedido_already_has_one _\ntests\\unit\\test_caja_models.py:671: in test_should_prevent_duplicate_facturas_when_pedido_already_has_one\n    FacturaFactory(pedido=pedido, folio=\"F-FIRST-001\")\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n============================== warnings summary ===============================\ntests/unit/test_caja_models.py: 110 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_onetoone_relationship_with_pedido\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_unique_folio_when_creating_duplicate\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_handle_created_by_field_when_user_provided\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_have_correct_string_representation_when_created\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_protect_pedido_when_factura_exists\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_relate_to_pedido_correctly_through_onetoone\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_calculate_saldo_final_correctly_when_movements_processed\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_handle_factura_generation_workflow_when_pedido_completed\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_prevent_duplicate_facturas_when_pedido_already_has_one\n================= 9 failed, 30 passed, 110 warnings in 1.19s ==================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/unit/test_ventas_models.py -v --tb=short",
      "description": "Unit Tests - test_ventas_models.py",
      "returncode": 1,
      "execution_time": 3.0284507274627686,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 27 items\n\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_allow_valid_estados_when_creating_pedido PASSED [  3%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_allow_valid_tipos_when_creating_pedido PASSED [  7%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_calculate_es_completado_correctly_when_percentage_set PASSED [ 11%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_calculate_monto_pendiente_correctly_when_percentage_set PASSED [ 14%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_calculate_puede_entrega_parcial_when_conditions_met PASSED [ 18%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_convert_to_venta_when_completed FAILED [ 22%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_create_pedido_with_required_fields_when_valid_data_provided PASSED [ 25%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_generate_unique_ticket_number_when_called PASSED [ 29%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_handle_pedido_padre_hijo_relationship_correctly PASSED [ 33%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_have_correct_string_representation_when_created PASSED [ 37%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_not_convert_to_venta_when_not_completed PASSED [ 40%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_set_audit_fields_when_created_by_user PASSED [ 44%]\ntests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_validate_decimal_fields_precision_when_creating FAILED [ 48%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_calculate_subtotal_correctly_when_business_logic_applied FAILED [ 51%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_create_detalle_pedido_with_required_fields_when_valid_data_provided PASSED [ 55%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_enforce_positive_cantidad_when_creating FAILED [ 59%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_handle_multiple_detalles_per_pedido_when_different_products FAILED [ 62%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_have_correct_string_representation_when_created FAILED [ 66%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_maintain_referential_integrity_when_pedido_deleted FAILED [ 70%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_protect_producto_when_detalle_exists FAILED [ 74%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_pedido_correctly_through_foreign_key FAILED [ 77%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_producto_correctly_through_foreign_key FAILED [ 81%]\ntests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_validate_decimal_precision_when_creating_detalle FAILED [ 85%]\ntests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_handle_complex_pedido_workflows_when_state_changes PASSED [ 88%]\ntests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_handle_concurrent_pedido_operations_when_multiple_users PASSED [ 92%]\ntests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_update_porcentaje_completado_when_method_called FAILED [ 96%]\ntests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_validate_business_rules_when_creating_complex_pedido PASSED [100%]\n\n================================== FAILURES ===================================\n_______ PedidoModelTestCase.test_should_convert_to_venta_when_completed _______\ntests\\unit\\test_ventas_models.py:174: in test_should_convert_to_venta_when_completed\n    pedido.convertir_a_venta()\nventas\\models.py:86: in convertir_a_venta\n    self.save(update_fields=['estado', 'fecha_conversion_venta'])\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1138: in _save_table\n    updated = self._do_update(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1203: in _do_update\n    return filtered._update(values) > 0\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1284: in _update\n    return query.get_compiler(self.db).execute_sql(ROW_COUNT)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:2060: in execute_sql\n    row_count = super().execute_sql(result_type)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1610: in execute_sql\n    sql, params = self.as_sql()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:2000: in as_sql\n    raise FieldError(\nE   django.core.exceptions.FieldError: Aggregate functions are not allowed in this query (fecha_conversion_venta=<MagicMock name='now().resolve_expression().resolve_expression()' id='2950996148304'>).\n_ PedidoModelTestCase.test_should_validate_decimal_fields_precision_when_creating _\ntests\\unit\\test_ventas_models.py:227: in test_should_validate_decimal_fields_precision_when_creating\n    with self.assertRaises(Exception):  # Django truncar\u00e1 o dar\u00e1 error\nE   AssertionError: Exception not raised\n_ DetallePedidoModelTestCase.test_should_calculate_subtotal_correctly_when_business_logic_applied _\ntests\\unit\\test_ventas_models.py:309: in test_should_calculate_subtotal_correctly_when_business_logic_applied\n    detalle = DetallePedidoFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_enforce_positive_cantidad_when_creating _\ntests\\unit\\test_ventas_models.py:276: in test_should_enforce_positive_cantidad_when_creating\n    with self.assertRaises(IntegrityError):\nE   AssertionError: IntegrityError not raised\n_ DetallePedidoModelTestCase.test_should_handle_multiple_detalles_per_pedido_when_different_products _\ntests\\unit\\test_ventas_models.py:327: in test_should_handle_multiple_detalles_per_pedido_when_different_products\n    detalle1 = DetallePedidoFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_have_correct_string_representation_when_created _\ntests\\unit\\test_ventas_models.py:266: in test_should_have_correct_string_representation_when_created\n    detalle = DetallePedidoFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_maintain_referential_integrity_when_pedido_deleted _\ntests\\unit\\test_ventas_models.py:287: in test_should_maintain_referential_integrity_when_pedido_deleted\n    detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_protect_producto_when_detalle_exists _\ntests\\unit\\test_ventas_models.py:297: in test_should_protect_producto_when_detalle_exists\n    DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_relate_to_pedido_correctly_through_foreign_key _\ntests\\unit\\test_ventas_models.py:359: in test_should_relate_to_pedido_correctly_through_foreign_key\n    detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_relate_to_producto_correctly_through_foreign_key _\ntests\\unit\\test_ventas_models.py:369: in test_should_relate_to_producto_correctly_through_foreign_key\n    detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DetallePedidoModelTestCase.test_should_validate_decimal_precision_when_creating_detalle _\ntests\\unit\\test_ventas_models.py:348: in test_should_validate_decimal_precision_when_creating_detalle\n    with self.assertRaises(Exception):  # Django truncar\u00e1 o dar\u00e1 error\nE   AssertionError: Exception not raised\n_ PedidoBusinessLogicTestCase.test_should_update_porcentaje_completado_when_method_called _\ntests\\unit\\test_ventas_models.py:393: in test_should_update_porcentaje_completado_when_method_called\n    DetallePedidoFactory(pedido=pedido, producto=self.producto, cantidad=10)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n============================== warnings summary ===============================\ntests/unit/test_ventas_models.py: 141 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_convert_to_venta_when_completed\nFAILED tests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_validate_decimal_fields_precision_when_creating\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_calculate_subtotal_correctly_when_business_logic_applied\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_enforce_positive_cantidad_when_creating\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_handle_multiple_detalles_per_pedido_when_different_products\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_have_correct_string_representation_when_created\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_maintain_referential_integrity_when_pedido_deleted\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_protect_producto_when_detalle_exists\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_pedido_correctly_through_foreign_key\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_producto_correctly_through_foreign_key\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_validate_decimal_precision_when_creating_detalle\nFAILED tests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_update_porcentaje_completado_when_method_called\n================= 12 failed, 15 passed, 141 warnings in 1.25s =================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/integration/ -v --tb=short",
      "description": "Integration Tests",
      "returncode": 1,
      "execution_time": 8.229338645935059,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 61 items\n\ntests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_create_producto_via_api FAILED [  1%]\ntests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_list_productos_api FAILED [  3%]\ntests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_search_productos_api FAILED [  4%]\ntests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_update_producto_via_api FAILED [  6%]\ntests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_create_pedido_via_api FAILED [  8%]\ntests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_list_pedidos_api FAILED [  9%]\ntests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_process_payment_via_api FAILED [ 11%]\ntests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_create_cliente_via_api FAILED [ 13%]\ntests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_get_cliente_purchase_history_api FAILED [ 14%]\ntests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_list_clientes_api FAILED [ 16%]\ntests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_get_low_stock_alert_api FAILED [ 18%]\ntests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_list_inventario_api FAILED [ 19%]\ntests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_update_stock_via_api FAILED [ 21%]\ntests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_close_caja_via_api FAILED [ 22%]\ntests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_get_caja_summary_api FAILED [ 24%]\ntests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_open_caja_via_api FAILED [ 26%]\ntests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_authenticate_with_token FAILED [ 27%]\ntests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_handle_invalid_token FAILED [ 29%]\ntests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_reject_unauthenticated_requests PASSED [ 31%]\ntests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_business_rules FAILED [ 32%]\ntests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_data_types FAILED [ 34%]\ntests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_required_fields_on_create FAILED [ 36%]\ntests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_handle_page_parameters FAILED [ 37%]\ntests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_paginate_large_result_sets FAILED [ 39%]\ntests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_alert_when_inventory_below_minimum FAILED [ 40%]\ntests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_prevent_overselling FAILED [ 42%]\ntests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_reduce_inventory_when_order_is_created FAILED [ 44%]\ntests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_create_cash_transaction_when_order_is_paid FAILED [ 45%]\ntests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_handle_partial_payments_with_advances FAILED [ 47%]\ntests/integration/test_business_flows.py::ClientesVentasIntegrationTestCase::test_should_accumulate_customer_purchase_history FAILED [ 49%]\ntests/integration/test_business_flows.py::ClientesVentasIntegrationTestCase::test_should_use_customer_credit_balance_for_payment PASSED [ 50%]\ntests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_handle_cascade_deletions_properly FAILED [ 52%]\ntests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_maintain_referential_integrity FAILED [ 54%]\ntests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_prevent_invalid_operations FAILED [ 55%]\ntests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_complete_sale_workflow FAILED [ 57%]\ntests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_return_workflow FAILED [ 59%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_complete_daily_cash_cycle FAILED [ 60%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_daily_cash_report FAILED [ 62%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_invoices_workflow FAILED [ 63%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_advances_workflow FAILED [ 65%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_discrepancies FAILED [ 67%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_transfers_between_boxes FAILED [ 68%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_charge_notes_workflow FAILED [ 70%]\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_track_multiple_payment_methods FAILED [ 72%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_customer_return_workflow FAILED [ 73%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_exchange_return_workflow FAILED [ 75%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_partial_returns FAILED [ 77%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_supplier_return_workflow FAILED [ 78%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_integrate_returns_with_loyalty_program FAILED [ 80%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_track_return_statistics FAILED [ 81%]\ntests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_validate_return_timeframe FAILED [ 83%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_calculate_complex_pricing FAILED [ 85%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_complete_full_sales_workflow FAILED [ 86%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_insufficient_inventory FAILED [ 88%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_partial_deliveries FAILED [ 90%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_sales_cancellation FAILED [ 91%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_integrate_with_cash_register FAILED [ 93%]\ntests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_track_sales_by_period FAILED [ 95%]\ntests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_complete_inventory_transfer_workflow FAILED [ 96%]\ntests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_prevent_negative_inventory FAILED [ 98%]\ntests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_track_inventory_movements FAILED [100%]\n\n================================== FAILURES ===================================\n_____ ProductosAPIIntegrationTestCase.test_should_create_producto_via_api _____\ntests\\integration\\test_api_endpoints.py:30: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n---------------------------- Captured stderr setup ----------------------------\nCreating test database for alias 'default'...\n\n_______ ProductosAPIIntegrationTestCase.test_should_list_productos_api ________\ntests\\integration\\test_api_endpoints.py:30: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ ProductosAPIIntegrationTestCase.test_should_search_productos_api _______\ntests\\integration\\test_api_endpoints.py:30: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_____ ProductosAPIIntegrationTestCase.test_should_update_producto_via_api _____\ntests\\integration\\test_api_endpoints.py:30: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_______ VentasAPIIntegrationTestCase.test_should_create_pedido_via_api ________\ntests\\integration\\test_api_endpoints.py:118: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n__________ VentasAPIIntegrationTestCase.test_should_list_pedidos_api __________\ntests\\integration\\test_api_endpoints.py:118: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ VentasAPIIntegrationTestCase.test_should_process_payment_via_api _______\ntests\\integration\\test_api_endpoints.py:118: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ ClientesAPIIntegrationTestCase.test_should_create_cliente_via_api ______\ntests\\integration\\test_api_endpoints.py:183: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_ ClientesAPIIntegrationTestCase.test_should_get_cliente_purchase_history_api _\ntests\\integration\\test_api_endpoints.py:183: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n________ ClientesAPIIntegrationTestCase.test_should_list_clientes_api _________\ntests\\integration\\test_api_endpoints.py:183: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n____ InventarioAPIIntegrationTestCase.test_should_get_low_stock_alert_api _____\ntests\\integration\\test_api_endpoints.py:232: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ InventarioAPIIntegrationTestCase.test_should_list_inventario_api _______\ntests\\integration\\test_api_endpoints.py:232: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ InventarioAPIIntegrationTestCase.test_should_update_stock_via_api ______\ntests\\integration\\test_api_endpoints.py:232: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n__________ CajaAPIIntegrationTestCase.test_should_close_caja_via_api __________\ntests\\integration\\test_api_endpoints.py:282: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_________ CajaAPIIntegrationTestCase.test_should_get_caja_summary_api _________\ntests\\integration\\test_api_endpoints.py:282: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n__________ CajaAPIIntegrationTestCase.test_should_open_caja_via_api ___________\ntests\\integration\\test_api_endpoints.py:282: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n__ AuthenticationAPIIntegrationTestCase.test_should_authenticate_with_token ___\ntests\\integration\\test_api_endpoints.py:336: in test_should_authenticate_with_token\n    token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n____ AuthenticationAPIIntegrationTestCase.test_should_handle_invalid_token ____\ntests\\integration\\test_api_endpoints.py:375: in test_should_handle_invalid_token\n    self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)\nE   AssertionError: 403 != 401\n---------------------------- Captured stderr call -----------------------------\nForbidden: /api/productos/\n------------------------------ Captured log call ------------------------------\nWARNING  django.request:log.py:248 Forbidden: /api/productos/\n____ APIValidationIntegrationTestCase.test_should_validate_business_rules _____\ntests\\integration\\test_api_endpoints.py:383: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n______ APIValidationIntegrationTestCase.test_should_validate_data_types _______\ntests\\integration\\test_api_endpoints.py:383: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_ APIValidationIntegrationTestCase.test_should_validate_required_fields_on_create _\ntests\\integration\\test_api_endpoints.py:383: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_____ APIPaginationIntegrationTestCase.test_should_handle_page_parameters _____\ntests\\integration\\test_api_endpoints.py:447: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n___ APIPaginationIntegrationTestCase.test_should_paginate_large_result_sets ___\ntests\\integration\\test_api_endpoints.py:447: in setUp\n    self.token = Token.objects.create(user=self.user)\nE   AttributeError: type object 'Token' has no attribute 'objects'\n_ VentasInventarioIntegrationTestCase.test_should_alert_when_inventory_below_minimum _\ntests\\integration\\test_business_flows.py:39: in setUp\n    self.inventario = InventarioFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n_____ VentasInventarioIntegrationTestCase.test_should_prevent_overselling _____\ntests\\integration\\test_business_flows.py:39: in setUp\n    self.inventario = InventarioFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n_ VentasInventarioIntegrationTestCase.test_should_reduce_inventory_when_order_is_created _\ntests\\integration\\test_business_flows.py:39: in setUp\n    self.inventario = InventarioFactory(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n_ VentasCajaIntegrationTestCase.test_should_create_cash_transaction_when_order_is_paid _\ntests\\integration\\test_business_flows.py:123: in setUp\n    self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n_ VentasCajaIntegrationTestCase.test_should_handle_partial_payments_with_advances _\ntests\\integration\\test_business_flows.py:123: in setUp\n    self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n_ ClientesVentasIntegrationTestCase.test_should_accumulate_customer_purchase_history _\ntests\\integration\\test_business_flows.py:263: in test_should_accumulate_customer_purchase_history\n    ).aggregate(total=models.Sum('total'))['total']\nE   NameError: name 'models' is not defined\n_ DataConsistencyIntegrationTestCase.test_should_handle_cascade_deletions_properly _\ntests\\integration\\test_business_flows.py:426: in test_should_handle_cascade_deletions_properly\n    detalle = DetallePedidoFactory(pedido=pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n_ DataConsistencyIntegrationTestCase.test_should_maintain_referential_integrity _\ntests\\integration\\test_business_flows.py:411: in test_should_maintain_referential_integrity\n    detalle = DetallePedidoFactory(pedido=pedido, producto=self.producto)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n__ DataConsistencyIntegrationTestCase.test_should_prevent_invalid_operations __\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:105: in _execute\n    return self.cursor.execute(sql, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\sqlite3\\base.py:360: in execute\n    return super().execute(query, params)\nE   sqlite3.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n  File \"C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py\", line 105, in _execute\n    return self.cursor.execute(sql, params)\n           ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\n  File \"C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\sqlite3\\base.py\", line 360, in execute\n    return super().execute(query, params)\n           ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^\nsqlite3.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nThe above exception was the direct cause of the following exception:\n\ndjango.db.utils.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nThe above exception was the direct cause of the following exception:\ntests\\integration\\test_business_flows.py:443: in test_should_prevent_invalid_operations\n    pedido = PedidoFactory(cliente=self.cliente, tienda=self.tienda)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:270: in build\n    step.resolve(pre)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:211: in resolve\n    self.attributes[field_name] = getattr(self.stub, field_name)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:356: in __getattr__\n    value = value.evaluate_pre(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\declarations.py:67: in evaluate_pre\n    return self.evaluate(instance, step, context)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\declarations.py:457: in evaluate\n    return step.recurse(subfactory, extra, force_sequence=force_sequence)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:228: in recurse\n    return builder.build(parent_step=self, force_sequence=force_sequence)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:663: in create\n    obj.save(force_insert=True, using=self.db)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\contrib\\auth\\base_user.py:65: in save\n    super().save(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1169: in _save_table\n    results = self._do_insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1210: in _do_insert\n    return manager._insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1864: in _insert\n    return query.get_compiler(using=using).execute_sql(returning_fields)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1882: in execute_sql\n    cursor.execute(sql, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:79: in execute\n    return self._execute_with_wrappers(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:92: in _execute_with_wrappers\n    return executor(sql, params, many, context)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:99: in _execute\n    self.db.validate_no_broken_transaction()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\base\\base.py:521: in validate_no_broken_transaction\n    raise TransactionManagementError(\nE   django.db.transaction.TransactionManagementError: An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\n_______ BusinessWorkflowIntegrationTestCase.test_complete_sale_workflow _______\ntests\\integration\\test_business_flows.py:287: in setUp\n    self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n__________ BusinessWorkflowIntegrationTestCase.test_return_workflow ___________\ntests\\integration\\test_business_flows.py:287: in setUp\n    self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n________ CajaIntegrationTestCase.test_should_complete_daily_cash_cycle ________\ntests\\integration\\test_cash_operations.py:42: in test_should_complete_daily_cash_cycle\n    self.assertDecimalEqual(self.caja.saldo_final, Decimal('1000.00'))\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n_______ CajaIntegrationTestCase.test_should_generate_daily_cash_report ________\ntests\\integration\\test_cash_operations.py:444: in test_should_generate_daily_cash_report\n    self.assertDecimalEqual(reporte['total_ingresos'], Decimal('450.00'))  # 100+150+200\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n_______ CajaIntegrationTestCase.test_should_generate_invoices_workflow ________\ntests\\integration\\test_cash_operations.py:216: in test_should_generate_invoices_workflow\n    factura = Factura.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Factura() got unexpected keyword arguments: 'numero', 'subtotal', 'iva'\n______ CajaIntegrationTestCase.test_should_handle_cash_advances_workflow ______\ntests\\integration\\test_cash_operations.py:92: in test_should_handle_cash_advances_workflow\n    anticipo = Anticipo.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Anticipo() got unexpected keyword arguments: 'tienda', 'estado'\n________ CajaIntegrationTestCase.test_should_handle_cash_discrepancies ________\ntests\\integration\\test_cash_operations.py:288: in test_should_handle_cash_discrepancies\n    self.assertDecimalEqual(self.caja.saldo_final, conteo_fisico)\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n___ CajaIntegrationTestCase.test_should_handle_cash_transfers_between_boxes ___\ntests\\integration\\test_cash_operations.py:382: in test_should_handle_cash_transfers_between_boxes\n    self.assertDecimalEqual(self.caja.saldo_final, Decimal('800.00'))  # 1000 - 200\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n______ CajaIntegrationTestCase.test_should_handle_charge_notes_workflow _______\ntests\\integration\\test_cash_operations.py:188: in test_should_handle_charge_notes_workflow\n    self.assertDecimalEqual(self.caja.saldo_final, saldo_esperado)\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n_____ CajaIntegrationTestCase.test_should_track_multiple_payment_methods ______\ntests\\integration\\test_cash_operations.py:335: in test_should_track_multiple_payment_methods\n    self.assertDecimalEqual(total_transacciones, pedido.total)\nE   AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n_ DevolucionesIntegrationTestCase.test_should_complete_customer_return_workflow _\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_ DevolucionesIntegrationTestCase.test_should_complete_exchange_return_workflow _\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ DevolucionesIntegrationTestCase.test_should_handle_partial_returns ______\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_ DevolucionesIntegrationTestCase.test_should_handle_supplier_return_workflow _\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_ DevolucionesIntegrationTestCase.test_should_integrate_returns_with_loyalty_program _\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ DevolucionesIntegrationTestCase.test_should_track_return_statistics _____\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n____ DevolucionesIntegrationTestCase.test_should_validate_return_timeframe ____\ntests\\integration\\test_return_workflows.py:46: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_______ VentasIntegrationTestCase.test_should_calculate_complex_pricing _______\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ VentasIntegrationTestCase.test_should_complete_full_sales_workflow ______\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ VentasIntegrationTestCase.test_should_handle_insufficient_inventory _____\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_______ VentasIntegrationTestCase.test_should_handle_partial_deliveries _______\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_______ VentasIntegrationTestCase.test_should_handle_sales_cancellation _______\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ VentasIntegrationTestCase.test_should_integrate_with_cash_register ______\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_________ VentasIntegrationTestCase.test_should_track_sales_by_period _________\ntests\\integration\\test_sales_workflows.py:40: in setUp\n    self.inventario1 = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_ InventarioIntegrationTestCase.test_should_complete_inventory_transfer_workflow _\ntests\\integration\\test_sales_workflows.py:419: in setUp\n    self.inventario_origen = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n____ InventarioIntegrationTestCase.test_should_prevent_negative_inventory _____\ntests\\integration\\test_sales_workflows.py:419: in setUp\n    self.inventario_origen = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n_____ InventarioIntegrationTestCase.test_should_track_inventory_movements _____\ntests\\integration\\test_sales_workflows.py:419: in setUp\n    self.inventario_origen = Inventario.objects.create(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: in __init__\n    raise TypeError(\nE   TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n-------------------------- Captured stderr teardown ---------------------------\nDestroying test database for alias 'default'...\n\n============================== warnings summary ===============================\ntests/integration/test_api_endpoints.py: 24 warnings\ntests/integration/test_business_flows.py: 60 warnings\ntests/integration/test_cash_operations.py: 25 warnings\ntests/integration/test_return_workflows.py: 28 warnings\ntests/integration/test_sales_workflows.py: 44 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/integration/test_cash_operations.py: 8 warnings\ntests/integration/test_return_workflows.py: 7 warnings\ntests/integration/test_sales_workflows.py: 10 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: AdminUserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the AdminUserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_invoices_workflow\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_track_multiple_payment_methods\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1612: RuntimeWarning: DateTimeField Pedido.fecha received a naive datetime (2025-05-30 00:00:00) while time zone support is active.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_create_producto_via_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_list_productos_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_search_productos_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_update_producto_via_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_create_pedido_via_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_list_pedidos_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_process_payment_via_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_create_cliente_via_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_get_cliente_purchase_history_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_list_clientes_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_get_low_stock_alert_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_list_inventario_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_update_stock_via_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_close_caja_via_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_get_caja_summary_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_open_caja_via_api\nFAILED tests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_authenticate_with_token\nFAILED tests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_handle_invalid_token\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_business_rules\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_data_types\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_required_fields_on_create\nFAILED tests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_handle_page_parameters\nFAILED tests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_paginate_large_result_sets\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_alert_when_inventory_below_minimum\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_prevent_overselling\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_reduce_inventory_when_order_is_created\nFAILED tests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_create_cash_transaction_when_order_is_paid\nFAILED tests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_handle_partial_payments_with_advances\nFAILED tests/integration/test_business_flows.py::ClientesVentasIntegrationTestCase::test_should_accumulate_customer_purchase_history\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_handle_cascade_deletions_properly\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_maintain_referential_integrity\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_prevent_invalid_operations\nFAILED tests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_complete_sale_workflow\nFAILED tests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_return_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_complete_daily_cash_cycle\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_daily_cash_report\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_invoices_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_advances_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_discrepancies\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_transfers_between_boxes\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_charge_notes_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_track_multiple_payment_methods\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_customer_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_exchange_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_partial_returns\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_supplier_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_integrate_returns_with_loyalty_program\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_track_return_statistics\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_validate_return_timeframe\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_calculate_complex_pricing\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_complete_full_sales_workflow\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_insufficient_inventory\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_partial_deliveries\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_sales_cancellation\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_integrate_with_cash_register\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_track_sales_by_period\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_complete_inventory_transfer_workflow\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_prevent_negative_inventory\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_track_inventory_movements\n================= 59 failed, 2 passed, 208 warnings in 6.31s ==================\n",
      "stderr": ""
    },
    {
      "command": "python -m pytest tests/performance/ -v --tb=short -m performance",
      "description": "Performance Tests",
      "returncode": 1,
      "execution_time": 2.3791074752807617,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0 -- C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe\ncachedir: .pytest_cache\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollecting ... collected 9 items / 8 deselected / 1 selected\n\ntests/performance/test_performance.py::MemoryUsageTest::test_memory_efficient_bulk_operations FAILED [100%]\n\n================================== FAILURES ===================================\n____________ MemoryUsageTest.test_memory_efficient_bulk_operations ____________\ntests\\performance\\test_performance.py:320: in test_memory_efficient_bulk_operations\n    import psutil\nE   ModuleNotFoundError: No module named 'psutil'\n---------------------------- Captured stderr setup ----------------------------\nCreating test database for alias 'default'...\n\n-------------------------- Captured stderr teardown ---------------------------\nDestroying test database for alias 'default'...\n\n============================== warnings summary ===============================\ntests\\performance\\test_performance.py:314\n  C:\\catalog_pos\\tests\\performance\\test_performance.py:314: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html\n    @pytest.mark.performance\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/performance/test_performance.py::MemoryUsageTest::test_memory_efficient_bulk_operations\n================= 1 failed, 8 deselected, 1 warning in 0.41s ==================\n",
      "stderr": ""
    },
    {
      "command": "coverage run -m pytest tests/unit/ tests/integration/",
      "description": "Coverage Analysis - Test Execution",
      "returncode": 1,
      "execution_time": 23.958510160446167,
      "stdout": "============================= test session starts =============================\nplatform win32 -- Python 3.13.3, pytest-8.3.4, pluggy-1.5.0\ndjango: version: 5.2.1, settings: tests.settings_test (from env)\nrootdir: C:\\catalog_pos\nconfigfile: pytest.ini\nplugins: anyio-4.9.0, django-test-plus-2.2.4, Faker-37.3.0, langsmith-0.3.42, cov-6.1.1, django-4.11.1, flask-1.3.0, mock-3.14.0, sqlalchemy-0.2.1, xdist-3.7.0\ncollected 352 items\n\ntests\\unit\\test_administracion_models.py ..........F................     [  7%]\ntests\\unit\\test_caja_models.py .........................FFFFFF.F.F.F..   [ 18%]\ntests\\unit\\test_clientes_models.py ....................................  [ 28%]\ntests\\unit\\test_descuentos_models.py ..................                  [ 34%]\ntests\\unit\\test_devoluciones_models.py .......F.F..........F....F..      [ 42%]\ntests\\unit\\test_inventario_models.py ..............F.........F.......... [ 51%]\n..                                                                       [ 52%]\ntests\\unit\\test_productos_models.py ............................         [ 60%]\ntests\\unit\\test_proveedores_models.py ........................F....      [ 68%]\ntests\\unit\\test_tiendas_models.py .................F.FFF                 [ 75%]\ntests\\unit\\test_ventas_models.py .....F......FF.FFFFFFFF..F.             [ 82%]\ntests\\integration\\test_api_endpoints.py FFFFFFFFFFFFFFFFFF.FFFFF         [ 89%]\ntests\\integration\\test_business_flows.py FFFFFF.FFFFF                    [ 92%]\ntests\\integration\\test_cash_operations.py FFFFFFFF                       [ 95%]\ntests\\integration\\test_return_workflows.py FFFFFFF                       [ 97%]\ntests\\integration\\test_sales_workflows.py FFFFFFFFFF                     [100%]\n\n================================== FAILURES ===================================\n__ PerfilUsuarioModelTests.test_should_create_perfil_usuario_with_valid_data __\n\nself = <tests.unit.test_administracion_models.PerfilUsuarioModelTests testMethod=test_should_create_perfil_usuario_with_valid_data>\n\n    def test_should_create_perfil_usuario_with_valid_data(self):\n        \"\"\"Deber\u00eda crear un perfil de usuario con datos v\u00e1lidos\"\"\"\n        user = UserFactory()\n        tienda = TiendaFactory()\n    \n>       perfil = PerfilUsuarioFactory(\n            usuario=user,\n            telefono='555-1234',\n            tienda_asignada=tienda,\n            max_return_days=30\n        )\n\ntests\\unit\\test_administracion_models.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <PerfilUsuario: Perfil de user42>, args = ()\nkwargs = {'max_return_days': 30}\ncls = <class 'administracion.models.PerfilUsuario'>\nopts = <Options for PerfilUsuario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18A0A080>, val = False\nfield = <django.db.models.fields.BooleanField: requiere_cambio_password>\nis_related_object = False, rel_obj = <Tienda: Smith-Harris>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: PerfilUsuario() got unexpected keyword arguments: 'max_return_days'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ FacturaModelTestCase.test_should_enforce_onetoone_relationship_with_pedido __\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_enforce_onetoone_relationship_with_pedido>\n\n    def test_should_enforce_onetoone_relationship_with_pedido(self):\n        \"\"\"Debe validar relaci\u00f3n OneToOne con pedido\"\"\"\n        # Crear primera factura\n>       FacturaFactory(pedido=self.pedido)\n\ntests\\unit\\test_caja_models.py:445: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura  - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Jordan, Strickland and Davidson - 2025-05-30 19:08:20.940685+00:00>, 'cliente': <Cliente: Christo...ado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 20, 939316, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CBBBE0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Christopher Thompson>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ FacturaModelTestCase.test_should_enforce_unique_folio_when_creating_duplicate _\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_enforce_unique_folio_when_creating_duplicate>\n\n    def test_should_enforce_unique_folio_when_creating_duplicate(self):\n        \"\"\"Debe validar unicidad del folio\"\"\"\n        folio = \"F-UNIQUE-001\"\n    \n        # Crear primera factura\n>       FacturaFactory(pedido=self.pedido, folio=folio)\n\ntests\\unit\\test_caja_models.py:428: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura F-UNIQUE-001 - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Carroll-Bailey - 2025-05-30 19:08:21.090169+00:00>, 'cliente': <Cliente: Amanda Kelley>, 'estado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 89384, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CBA6B0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Amanda Kelley>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ FacturaModelTestCase.test_should_handle_created_by_field_when_user_provided _\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_handle_created_by_field_when_user_provided>\n\n    def test_should_handle_created_by_field_when_user_provided(self):\n        \"\"\"Debe manejar campo created_by cuando se proporciona usuario\"\"\"\n>       factura = FacturaFactory(\n            pedido=self.pedido,\n            created_by=self.user\n        )\n\ntests\\unit\\test_caja_models.py:476: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura  - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Cruz, Rodriguez and Lynch - 2025-05-30 19:08:21.234626+00:00>, 'cliente': <Cliente: Steven Larson...ado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 233825, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18A09DB0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = True, rel_obj = <User: user181>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ FacturaModelTestCase.test_should_have_correct_string_representation_when_created _\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_have_correct_string_representation_when_created>\n\n    def test_should_have_correct_string_representation_when_created(self):\n        \"\"\"Debe tener una representaci\u00f3n string correcta\"\"\"\n>       factura = FacturaFactory(\n            pedido=self.pedido,\n            folio=\"F-TEST-123\"\n        )\n\ntests\\unit\\test_caja_models.py:416: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura F-TEST-123 - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Williams LLC - 2025-05-30 19:08:21.388733+00:00>, 'cliente': <Cliente: Margaret Smith>, 'estado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 387962, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CB97E0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Margaret Smith>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ FacturaModelTestCase.test_should_protect_pedido_when_factura_exists _____\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_protect_pedido_when_factura_exists>\n\n    def test_should_protect_pedido_when_factura_exists(self):\n        \"\"\"Debe proteger pedido cuando existe factura (PROTECT)\"\"\"\n>       FacturaFactory(pedido=self.pedido)\n\ntests\\unit\\test_caja_models.py:458: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura  - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Burgess, Bradford and Green - 2025-05-30 19:08:21.540764+00:00>, 'cliente': <Cliente: Eric Johnso...ado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 539862, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18A0BD30>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Eric Johnson>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ FacturaModelTestCase.test_should_relate_to_pedido_correctly_through_onetoone _\n\nself = <tests.unit.test_caja_models.FacturaModelTestCase testMethod=test_should_relate_to_pedido_correctly_through_onetoone>\n\n    def test_should_relate_to_pedido_correctly_through_onetoone(self):\n        \"\"\"Debe relacionarse correctamente con pedido a trav\u00e9s de OneToOne\"\"\"\n>       factura = FacturaFactory(pedido=self.pedido)\n\ntests\\unit\\test_caja_models.py:466: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura  - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Mueller, Sanchez and Richards - 2025-05-30 19:08:21.700045+00:00>, 'cliente': <Cliente: Justin Al...ado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 699071, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CE3340>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Justin Alexander>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ CajaBusinessLogicTestCase.test_should_calculate_saldo_final_correctly_when_movements_processed _\n\nself = <tests.unit.test_caja_models.CajaBusinessLogicTestCase testMethod=test_should_calculate_saldo_final_correctly_when_movements_processed>\n\n    def test_should_calculate_saldo_final_correctly_when_movements_processed(self):\n        \"\"\"Debe calcular saldo final correctamente cuando se procesan movimientos\"\"\"\n        caja = CajaFactory(\n            tienda=self.tienda,\n            fondo_inicial=Decimal('1000.00'),\n            fecha=date.today()\n        )\n    \n        # Crear movimientos\n        ingreso1 = TransaccionCaja.objects.create(\n            caja=caja,\n            tipo_movimiento='INGRESO',\n            monto=Decimal('500.00')\n        )\n    \n        ingreso2 = TransaccionCaja.objects.create(\n            caja=caja,\n            tipo_movimiento='INGRESO',\n            monto=Decimal('300.00')\n        )\n    \n        egreso1 = TransaccionCaja.objects.create(\n            caja=caja,\n            tipo_movimiento='EGRESO',\n            monto=Decimal('200.00')\n        )\n    \n        # Calcular totales\n        total_ingresos = caja.transacciones.filter(\n            tipo_movimiento='INGRESO'\n>       ).aggregate(total=models.Sum('monto'))['total'] or Decimal('0')\nE       NameError: name 'models' is not defined\n\ntests\\unit\\test_caja_models.py:533: NameError\n_ CajaBusinessLogicTestCase.test_should_handle_factura_generation_workflow_when_pedido_completed _\n\nself = <tests.unit.test_caja_models.CajaBusinessLogicTestCase testMethod=test_should_handle_factura_generation_workflow_when_pedido_completed>\n\n    def test_should_handle_factura_generation_workflow_when_pedido_completed(self):\n        \"\"\"Debe manejar flujo de generaci\u00f3n de facturas cuando se completa pedido\"\"\"\n        pedido = PedidoFactory(\n            cliente=self.cliente,\n            tienda=self.tienda,\n            estado='surtido',\n            pagado=True,\n            total=Decimal('1500.00')\n        )\n    \n        # Crear factura para el pedido\n>       factura = FacturaFactory(\n            pedido=pedido,\n            folio=\"F-2025-TEST-001\",\n            total=pedido.total,\n            created_by=self.user\n        )\n\ntests\\unit\\test_caja_models.py:654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura F-2025-TEST-001 - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Mcdonald and Sons - 2025-05-30 19:08:21.902740+00:00>, 'cliente': <Cliente: Michael Ward>, 'estado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 21, 901912, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CE0BB0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = True, rel_obj = <User: user208>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ CajaBusinessLogicTestCase.test_should_prevent_duplicate_facturas_when_pedido_already_has_one _\n\nself = <tests.unit.test_caja_models.CajaBusinessLogicTestCase testMethod=test_should_prevent_duplicate_facturas_when_pedido_already_has_one>\n\n    def test_should_prevent_duplicate_facturas_when_pedido_already_has_one(self):\n        \"\"\"Debe prevenir facturas duplicadas cuando el pedido ya tiene una\"\"\"\n        pedido = PedidoFactory(cliente=self.cliente, tienda=self.tienda)\n    \n        # Crear primera factura\n>       FacturaFactory(pedido=pedido, folio=\"F-FIRST-001\")\n\ntests\\unit\\test_caja_models.py:671: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura F-FIRST-001 - Pedido 1>, args = ()\nkwargs = {'caja': <Caja: Caja Pearson and Sons - 2025-05-30 19:08:22.066183+00:00>, 'cliente': <Cliente: Benjamin Ballard>, 'estado': 'emitida', 'fecha_emision': datetime.datetime(2025, 5, 30, 19, 8, 22, 65317, tzinfo=datetime.timezone.utc), ...}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18CE0820>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = False, rel_obj = <Pedido: Pedido 1 - Benjamin Ballard>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero_factura', 'cliente', 'fecha_emision', 'subtotal', 'impuestos', 'estado', 'metodo_pago', 'caja'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n___ TestDevolucionModel.test_should_handle_null_detalle_pedido_on_deletion ____\n\nself = <tests.unit.test_devoluciones_models.TestDevolucionModel testMethod=test_should_handle_null_detalle_pedido_on_deletion>\n\n    def test_should_handle_null_detalle_pedido_on_deletion(self):\n        \"\"\"Debe manejar eliminaci\u00f3n de detalle pedido (SET_NULL).\"\"\"\n>       detalle = DetallePedidoFactory()\n\ntests\\unit\\test_devoluciones_models.py:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00008 x 4 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E0CA30>\nval = Decimal('601.320')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00008 - Converse Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n______ TestDevolucionModel.test_should_link_to_detalle_pedido_optionally ______\n\nself = <tests.unit.test_devoluciones_models.TestDevolucionModel testMethod=test_should_link_to_detalle_pedido_optionally>\n\n    def test_should_link_to_detalle_pedido_optionally(self):\n        \"\"\"Debe linkear opcionalmente a detalle de pedido.\"\"\"\n        pedido = PedidoFactory()\n>       detalle = DetallePedidoFactory(pedido=pedido)\n\ntests\\unit\\test_devoluciones_models.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00010 x 2 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E0E800>\nval = Decimal('376.830')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00010 - Puma Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n______ TestDevolucionWorkflow.test_should_process_defect_return_workflow ______\n\nself = <tests.unit.test_devoluciones_models.TestDevolucionWorkflow testMethod=test_should_process_defect_return_workflow>\n\n    def test_should_process_defect_return_workflow(self):\n        \"\"\"Debe procesar flujo de devoluci\u00f3n por defecto.\"\"\"\n        # Crear contexto inicial\n        cliente = ClienteFactory()\n        producto = ProductoFactory(precio=Decimal('100.00'))\n        pedido = PedidoFactory(cliente=cliente)\n>       detalle = DetallePedidoFactory(\n            pedido=pedido,\n            producto=producto,\n            cantidad=2,\n            precio_unitario=Decimal('100.00')\n        )\n\ntests\\unit\\test_devoluciones_models.py:228: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00022 x 2 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18B85C60>\nval = Decimal('200.00')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00022 - Adidas Classic>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n___ TestDevolucionIntegration.test_should_link_devolucion_to_original_sale ____\n\nself = <tests.unit.test_devoluciones_models.TestDevolucionIntegration testMethod=test_should_link_devolucion_to_original_sale>\n\n    def test_should_link_devolucion_to_original_sale(self):\n        \"\"\"Debe linkear devoluci\u00f3n a venta original.\"\"\"\n        # Crear venta original\n        cliente = ClienteFactory()\n        producto = ProductoFactory()\n        pedido = PedidoFactory(cliente=cliente, estado='entregado')\n>       detalle = DetallePedidoFactory(\n            pedido=pedido,\n            producto=producto,\n            cantidad=3,\n            precio_unitario=Decimal('50.00')\n        )\n\ntests\\unit\\test_devoluciones_models.py:338: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00027 x 3 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E4C820>\nval = Decimal('150.00')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00027 - Converse Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n________ TraspasoModelTestCase.test_should_auto_set_fecha_when_created ________\n\nself = <tests.unit.test_inventario_models.TraspasoModelTestCase testMethod=test_should_auto_set_fecha_when_created>\n\n    def test_should_auto_set_fecha_when_created(self):\n        \"\"\"Debe establecer autom\u00e1ticamente la fecha cuando se crea\"\"\"\n        with patch('django.utils.timezone.now') as mock_now:\n            mock_time = timezone.now()\n            mock_now.return_value = mock_time\n    \n>           traspaso = Traspaso.objects.create(\n                tienda_origen=self.tienda_origen,\n                tienda_destino=self.tienda_destino\n            )\n\ntests\\unit\\test_inventario_models.py:277: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:663: in create\n    obj.save(force_insert=True, using=self.db)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1169: in _save_table\n    results = self._do_insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1210: in _do_insert\n    return manager._insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1864: in _insert\n    return query.get_compiler(using=using).execute_sql(returning_fields)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1881: in execute_sql\n    for sql, params in self.as_sql():\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1806: in as_sql\n    self.prepare_value(field, self.pre_save_val(field, obj))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <SQLInsertCompiler model=Traspaso connection=<DatabaseWrapper vendor='sqlite' alias='default'> using='default'>\nfield = <django.db.models.fields.DateTimeField: fecha>\nvalue = <MagicMock name='now().resolve_expression()' id='2942473281488'>\n\n    def prepare_value(self, field, value):\n        \"\"\"\n        Prepare a value to be used in a query by resolving it if it is an\n        expression and otherwise calling the field's get_db_prep_save().\n        \"\"\"\n        if hasattr(value, \"resolve_expression\"):\n            value = value.resolve_expression(\n                self.query, allow_joins=False, for_save=True\n            )\n            # Don't allow values containing Col expressions. They refer to\n            # existing columns on a row, but in the case of insert the row\n            # doesn't exist yet.\n            if value.contains_column_references:\n>               raise ValueError(\n                    'Failed to insert expression \"%s\" on %s. F() expressions '\n                    \"can only be used to update, not to insert.\" % (value, field)\n                )\nE               ValueError: Failed to insert expression \"<MagicMock name='now().resolve_expression()' id='2942473281488'>\" on inventario.Traspaso.fecha. F() expressions can only be used to update, not to insert.\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1727: ValueError\n_ TraspasoItemModelTestCase.test_should_enforce_positive_cantidad_when_creating _\n\nself = <tests.unit.test_inventario_models.TraspasoItemModelTestCase testMethod=test_should_enforce_positive_cantidad_when_creating>\n\n    def test_should_enforce_positive_cantidad_when_creating(self):\n        \"\"\"Debe validar que la cantidad sea positiva\"\"\"\n>       with self.assertRaises(IntegrityError):\nE       AssertionError: IntegrityError not raised\n\ntests\\unit\\test_inventario_models.py:324: AssertionError\n_____ TestPurchaseOrderItemModel.test_should_validate_positive_quantities _____\n\nself = <tests.unit.test_proveedores_models.TestPurchaseOrderItemModel testMethod=test_should_validate_positive_quantities>\n\n    def test_should_validate_positive_quantities(self):\n        \"\"\"Debe validar cantidades positivas.\"\"\"\n        item = PurchaseOrderItemFactory()\n    \n>       with pytest.raises(ValidationError):\nE       Failed: DID NOT RAISE <class 'django.core.exceptions.ValidationError'>\n\ntests\\unit\\test_proveedores_models.py:225: Failed\n________ TestTiendaIntegration.test_should_handle_tienda_name_searches ________\n\nself = <tests.unit.test_tiendas_models.TestTiendaIntegration testMethod=test_should_handle_tienda_name_searches>\n\n    def test_should_handle_tienda_name_searches(self):\n        \"\"\"Debe manejar b\u00fasquedas por nombre de tienda.\"\"\"\n        TiendaFactory(nombre=\"Centro Comercial Plaza\")\n        TiendaFactory(nombre=\"Plaza del Valle\")\n        TiendaFactory(nombre=\"Mercado Central\")\n    \n        # B\u00fasqueda por contenido\n        tiendas_plaza = Tienda.objects.filter(nombre__icontains=\"Plaza\")\n        tiendas_centro = Tienda.objects.filter(nombre__icontains=\"Centro\")\n    \n        assert tiendas_plaza.count() == 2\n>       assert tiendas_centro.count() == 2\nE       assert 1 == 2\nE        +  where 1 = count()\nE        +    where count = <QuerySet [<Tienda: Centro Comercial Plaza>]>.count\n\ntests\\unit\\test_tiendas_models.py:234: AssertionError\n_________ TestTiendaIntegration.test_should_preserve_tienda_hierarchy _________\n\nself = <tests.unit.test_tiendas_models.TestTiendaIntegration testMethod=test_should_preserve_tienda_hierarchy>\n\n    def test_should_preserve_tienda_hierarchy(self):\n        \"\"\"Debe preservar jerarqu\u00eda de tiendas si existe.\"\"\"\n        # En un sistema real, podr\u00eda haber tienda matriz y sucursales\n        tienda_matriz = TiendaFactory(nombre=\"Matriz\")\n        sucursal_1 = TiendaFactory(nombre=\"Sucursal 1\")\n        sucursal_2 = TiendaFactory(nombre=\"Sucursal 2\")\n    \n        # Verificar que todas existen independientemente\n>       assert Tienda.objects.count() == 3\nE       assert 4 == 3\nE        +  where 4 = count()\nE        +    where count = <django.db.models.manager.Manager object at 0x000002AD1838C450>.count\nE        +      where <django.db.models.manager.Manager object at 0x000002AD1838C450> = Tienda.objects\n\ntests\\unit\\test_tiendas_models.py:244: AssertionError\n_____ TestTiendaIntegration.test_should_support_geographical_organization _____\n\nself = <tests.unit.test_tiendas_models.TestTiendaIntegration testMethod=test_should_support_geographical_organization>\n\n    def test_should_support_geographical_organization(self):\n        \"\"\"Debe soportar organizaci\u00f3n geogr\u00e1fica.\"\"\"\n        tiendas_por_region = {\n            \"Norte\": [\"Tienda Maracaibo\", \"Tienda Valencia\"],\n            \"Sur\": [\"Tienda Puerto Ordaz\", \"Tienda San Crist\u00f3bal\"],\n            \"Centro\": [\"Tienda Caracas Centro\", \"Tienda Caracas Este\"]\n        }\n    \n        created_tiendas = {}\n        for region, nombres in tiendas_por_region.items():\n            created_tiendas[region] = []\n            for nombre in nombres:\n                tienda = TiendaFactory(nombre=nombre)\n                created_tiendas[region].append(tienda)\n    \n        # Verificar creaci\u00f3n\n>       assert Tienda.objects.count() == 6\nE       assert 7 == 6\nE        +  where 7 = count()\nE        +    where count = <django.db.models.manager.Manager object at 0x000002AD1838C450>.count\nE        +      where <django.db.models.manager.Manager object at 0x000002AD1838C450> = Tienda.objects\n\ntests\\unit\\test_tiendas_models.py:263: AssertionError\n______ TestTiendaIntegration.test_should_support_multi_store_operations _______\n\nself = <tests.unit.test_tiendas_models.TestTiendaIntegration testMethod=test_should_support_multi_store_operations>\n\n    def test_should_support_multi_store_operations(self):\n        \"\"\"Debe soportar operaciones multi-tienda.\"\"\"\n        tienda_norte = TiendaFactory(nombre=\"Tienda Norte\")\n        tienda_sur = TiendaFactory(nombre=\"Tienda Sur\")\n        tienda_este = TiendaFactory(nombre=\"Tienda Este\")\n    \n        todas_tiendas = Tienda.objects.all()\n        tiendas_activas = Tienda.objects.filter(activa=True)\n    \n>       assert todas_tiendas.count() == 3\nE       assert 4 == 3\nE        +  where 4 = count()\nE        +    where count = <QuerySet [<Tienda: Tienda Test>, <Tienda: Tienda Norte>, <Tienda: Tienda Sur>, <Tienda: Tienda Este>]>.count\n\ntests\\unit\\test_tiendas_models.py:213: AssertionError\n_______ PedidoModelTestCase.test_should_convert_to_venta_when_completed _______\n\nself = <tests.unit.test_ventas_models.PedidoModelTestCase testMethod=test_should_convert_to_venta_when_completed>\n\n    def test_should_convert_to_venta_when_completed(self):\n        \"\"\"Debe convertir a venta cuando est\u00e1 completado\"\"\"\n        pedido = PedidoFactory(\n            cliente=self.cliente,\n            tienda=self.tienda,\n            estado='surtido',\n            porcentaje_completado=Decimal('100.00')\n        )\n    \n        # Inicialmente sin fecha de conversi\u00f3n\n        self.assertIsNone(pedido.fecha_conversion_venta)\n    \n        # Convertir a venta\n        with patch('django.utils.timezone.now') as mock_now:\n            mock_time = timezone.now()\n            mock_now.return_value = mock_time\n    \n>           pedido.convertir_a_venta()\n\ntests\\unit\\test_ventas_models.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nventas\\models.py:86: in convertir_a_venta\n    self.save(update_fields=['estado', 'fecha_conversion_venta'])\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1138: in _save_table\n    updated = self._do_update(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1203: in _do_update\n    return filtered._update(values) > 0\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1284: in _update\n    return query.get_compiler(self.db).execute_sql(ROW_COUNT)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:2060: in execute_sql\n    row_count = super().execute_sql(result_type)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1610: in execute_sql\n    sql, params = self.as_sql()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <SQLUpdateCompiler model=Pedido connection=<DatabaseWrapper vendor='sqlite' alias='default'> using='default'>\n\n    def as_sql(self):\n        \"\"\"\n        Create the SQL for this query. Return the SQL string and list of\n        parameters.\n        \"\"\"\n        self.pre_sql_setup()\n        if not self.query.values:\n            return \"\", ()\n        qn = self.quote_name_unless_alias\n        values, update_params = [], []\n        for field, model, val in self.query.values:\n            if hasattr(val, \"resolve_expression\"):\n                val = val.resolve_expression(\n                    self.query, allow_joins=False, for_save=True\n                )\n                if val.contains_aggregate:\n>                   raise FieldError(\n                        \"Aggregate functions are not allowed in this query \"\n                        \"(%s=%r).\" % (field.name, val)\n                    )\nE                   django.core.exceptions.FieldError: Aggregate functions are not allowed in this query (fecha_conversion_venta=<MagicMock name='now().resolve_expression().resolve_expression()' id='2942473283504'>).\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:2000: FieldError\n_ PedidoModelTestCase.test_should_validate_decimal_fields_precision_when_creating _\n\nself = <tests.unit.test_ventas_models.PedidoModelTestCase testMethod=test_should_validate_decimal_fields_precision_when_creating>\n\n    def test_should_validate_decimal_fields_precision_when_creating(self):\n        \"\"\"Debe validar la precisi\u00f3n de campos decimales\"\"\"\n        # Total con demasiados decimales\n>       with self.assertRaises(Exception):  # Django truncar\u00e1 o dar\u00e1 error\nE       AssertionError: Exception not raised\n\ntests\\unit\\test_ventas_models.py:227: AssertionError\n_ DetallePedidoModelTestCase.test_should_calculate_subtotal_correctly_when_business_logic_applied _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_calculate_subtotal_correctly_when_business_logic_applied>\n\n    def test_should_calculate_subtotal_correctly_when_business_logic_applied(self):\n        \"\"\"Debe calcular subtotal correctamente seg\u00fan l\u00f3gica de negocio\"\"\"\n        cantidad = 10\n        precio_unitario = Decimal('25.50')\n        expected_subtotal = cantidad * precio_unitario\n    \n>       detalle = DetallePedidoFactory(\n            pedido=self.pedido,\n            producto=self.producto,\n            cantidad=cantidad,\n            precio_unitario=precio_unitario,\n            subtotal=expected_subtotal\n        )\n\ntests\\unit\\test_ventas_models.py:309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00122 x 10 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E4E3B0>\nval = Decimal('255.00')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00122 - Reebok Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_enforce_positive_cantidad_when_creating _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_enforce_positive_cantidad_when_creating>\n\n    def test_should_enforce_positive_cantidad_when_creating(self):\n        \"\"\"Debe validar que la cantidad sea positiva\"\"\"\n>       with self.assertRaises(IntegrityError):\nE       AssertionError: IntegrityError not raised\n\ntests\\unit\\test_ventas_models.py:276: AssertionError\n_ DetallePedidoModelTestCase.test_should_handle_multiple_detalles_per_pedido_when_different_products _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_handle_multiple_detalles_per_pedido_when_different_products>\n\n    def test_should_handle_multiple_detalles_per_pedido_when_different_products(self):\n        \"\"\"Debe manejar m\u00faltiples detalles por pedido con productos diferentes\"\"\"\n        producto2 = ProductoFactory(\n            codigo='P002',\n            proveedor=self.proveedor,\n            tienda=self.tienda\n        )\n    \n>       detalle1 = DetallePedidoFactory(\n            pedido=self.pedido,\n            producto=self.producto,\n            cantidad=2\n        )\n\ntests\\unit\\test_ventas_models.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00125 x 2 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE37C0>\nval = Decimal('941.760')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00125 - Nike Formal>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_have_correct_string_representation_when_created _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_have_correct_string_representation_when_created>\n\n    def test_should_have_correct_string_representation_when_created(self):\n        \"\"\"Debe tener una representaci\u00f3n string correcta\"\"\"\n>       detalle = DetallePedidoFactory(\n            pedido=self.pedido,\n            producto=self.producto,\n            cantidad=3\n        )\n\ntests\\unit\\test_ventas_models.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00127 x 3 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE1660>\nval = Decimal('639.315')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00127 - Nike Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_maintain_referential_integrity_when_pedido_deleted _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_maintain_referential_integrity_when_pedido_deleted>\n\n    def test_should_maintain_referential_integrity_when_pedido_deleted(self):\n        \"\"\"Debe mantener integridad referencial cuando se elimina pedido\"\"\"\n>       detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\n\ntests\\unit\\test_ventas_models.py:287: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00128 x 3 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD17D40EE0>\nval = Decimal('1279.845')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00128 - Reebok Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_protect_producto_when_detalle_exists _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_protect_producto_when_detalle_exists>\n\n    def test_should_protect_producto_when_detalle_exists(self):\n        \"\"\"Debe proteger producto cuando existe detalle (PROTECT)\"\"\"\n>       DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\n\ntests\\unit\\test_ventas_models.py:297: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00129 x 5 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE2B60>\nval = Decimal('2455.425')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00129 - Converse Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_relate_to_pedido_correctly_through_foreign_key _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_relate_to_pedido_correctly_through_foreign_key>\n\n    def test_should_relate_to_pedido_correctly_through_foreign_key(self):\n        \"\"\"Debe relacionarse correctamente con pedido a trav\u00e9s de foreign key\"\"\"\n>       detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\n\ntests\\unit\\test_ventas_models.py:359: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00130 x 4 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E4E380>\nval = Decimal('1789.320')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00130 - Reebok Formal>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_relate_to_producto_correctly_through_foreign_key _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_relate_to_producto_correctly_through_foreign_key>\n\n    def test_should_relate_to_producto_correctly_through_foreign_key(self):\n        \"\"\"Debe relacionarse correctamente con producto a trav\u00e9s de foreign key\"\"\"\n>       detalle = DetallePedidoFactory(pedido=self.pedido, producto=self.producto)\n\ntests\\unit\\test_ventas_models.py:369: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00131 x 5 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE1EA0>\nval = Decimal('585.600')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00131 - Nike Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DetallePedidoModelTestCase.test_should_validate_decimal_precision_when_creating_detalle _\n\nself = <tests.unit.test_ventas_models.DetallePedidoModelTestCase testMethod=test_should_validate_decimal_precision_when_creating_detalle>\n\n    def test_should_validate_decimal_precision_when_creating_detalle(self):\n        \"\"\"Debe validar precisi\u00f3n decimal en precios\"\"\"\n        # Precio con demasiados decimales\n>       with self.assertRaises(Exception):  # Django truncar\u00e1 o dar\u00e1 error\nE       AssertionError: Exception not raised\n\ntests\\unit\\test_ventas_models.py:348: AssertionError\n_ PedidoBusinessLogicTestCase.test_should_update_porcentaje_completado_when_method_called _\n\nself = <tests.unit.test_ventas_models.PedidoBusinessLogicTestCase testMethod=test_should_update_porcentaje_completado_when_method_called>\n\n    def test_should_update_porcentaje_completado_when_method_called(self):\n        \"\"\"Debe actualizar porcentaje completado cuando se llama el m\u00e9todo\"\"\"\n        pedido = PedidoFactory(cliente=self.cliente, tienda=self.tienda)\n    \n        # Agregar detalles\n>       DetallePedidoFactory(pedido=pedido, producto=self.producto, cantidad=10)\n\ntests\\unit\\test_ventas_models.py:393: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00135 x 10 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18B87130>\nval = Decimal('7005.450')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00135 - Puma Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ ProductosAPIIntegrationTestCase.test_should_create_producto_via_api _____\n\nself = <tests.integration.test_api_endpoints.ProductosAPIIntegrationTestCase testMethod=test_should_create_producto_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:30: AttributeError\n_______ ProductosAPIIntegrationTestCase.test_should_list_productos_api ________\n\nself = <tests.integration.test_api_endpoints.ProductosAPIIntegrationTestCase testMethod=test_should_list_productos_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:30: AttributeError\n______ ProductosAPIIntegrationTestCase.test_should_search_productos_api _______\n\nself = <tests.integration.test_api_endpoints.ProductosAPIIntegrationTestCase testMethod=test_should_search_productos_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:30: AttributeError\n_____ ProductosAPIIntegrationTestCase.test_should_update_producto_via_api _____\n\nself = <tests.integration.test_api_endpoints.ProductosAPIIntegrationTestCase testMethod=test_should_update_producto_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:30: AttributeError\n_______ VentasAPIIntegrationTestCase.test_should_create_pedido_via_api ________\n\nself = <tests.integration.test_api_endpoints.VentasAPIIntegrationTestCase testMethod=test_should_create_pedido_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:118: AttributeError\n__________ VentasAPIIntegrationTestCase.test_should_list_pedidos_api __________\n\nself = <tests.integration.test_api_endpoints.VentasAPIIntegrationTestCase testMethod=test_should_list_pedidos_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:118: AttributeError\n______ VentasAPIIntegrationTestCase.test_should_process_payment_via_api _______\n\nself = <tests.integration.test_api_endpoints.VentasAPIIntegrationTestCase testMethod=test_should_process_payment_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:118: AttributeError\n______ ClientesAPIIntegrationTestCase.test_should_create_cliente_via_api ______\n\nself = <tests.integration.test_api_endpoints.ClientesAPIIntegrationTestCase testMethod=test_should_create_cliente_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:183: AttributeError\n_ ClientesAPIIntegrationTestCase.test_should_get_cliente_purchase_history_api _\n\nself = <tests.integration.test_api_endpoints.ClientesAPIIntegrationTestCase testMethod=test_should_get_cliente_purchase_history_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:183: AttributeError\n________ ClientesAPIIntegrationTestCase.test_should_list_clientes_api _________\n\nself = <tests.integration.test_api_endpoints.ClientesAPIIntegrationTestCase testMethod=test_should_list_clientes_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:183: AttributeError\n____ InventarioAPIIntegrationTestCase.test_should_get_low_stock_alert_api _____\n\nself = <tests.integration.test_api_endpoints.InventarioAPIIntegrationTestCase testMethod=test_should_get_low_stock_alert_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:232: AttributeError\n______ InventarioAPIIntegrationTestCase.test_should_list_inventario_api _______\n\nself = <tests.integration.test_api_endpoints.InventarioAPIIntegrationTestCase testMethod=test_should_list_inventario_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:232: AttributeError\n______ InventarioAPIIntegrationTestCase.test_should_update_stock_via_api ______\n\nself = <tests.integration.test_api_endpoints.InventarioAPIIntegrationTestCase testMethod=test_should_update_stock_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:232: AttributeError\n__________ CajaAPIIntegrationTestCase.test_should_close_caja_via_api __________\n\nself = <tests.integration.test_api_endpoints.CajaAPIIntegrationTestCase testMethod=test_should_close_caja_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:282: AttributeError\n_________ CajaAPIIntegrationTestCase.test_should_get_caja_summary_api _________\n\nself = <tests.integration.test_api_endpoints.CajaAPIIntegrationTestCase testMethod=test_should_get_caja_summary_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:282: AttributeError\n__________ CajaAPIIntegrationTestCase.test_should_open_caja_via_api ___________\n\nself = <tests.integration.test_api_endpoints.CajaAPIIntegrationTestCase testMethod=test_should_open_caja_via_api>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:282: AttributeError\n__ AuthenticationAPIIntegrationTestCase.test_should_authenticate_with_token ___\n\nself = <tests.integration.test_api_endpoints.AuthenticationAPIIntegrationTestCase testMethod=test_should_authenticate_with_token>\n\n    def test_should_authenticate_with_token(self):\n        \"\"\"Debe autenticar con token\"\"\"\n>       token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:336: AttributeError\n____ AuthenticationAPIIntegrationTestCase.test_should_handle_invalid_token ____\n\nself = <tests.integration.test_api_endpoints.AuthenticationAPIIntegrationTestCase testMethod=test_should_handle_invalid_token>\n\n    def test_should_handle_invalid_token(self):\n        \"\"\"Debe manejar tokens inv\u00e1lidos\"\"\"\n        self.client.credentials(HTTP_AUTHORIZATION='Token invalid_token')\n    \n        url = '/api/productos/'\n        response = self.client.get(url)\n    \n        if response.status_code == status.HTTP_404_NOT_FOUND:\n            self.skipTest(\"API no implementada\")\n    \n>       self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)\nE       AssertionError: 403 != 401\n\ntests\\integration\\test_api_endpoints.py:375: AssertionError\n---------------------------- Captured stderr call -----------------------------\nForbidden: /api/productos/\n------------------------------ Captured log call ------------------------------\nWARNING  django.request:log.py:248 Forbidden: /api/productos/\n____ APIValidationIntegrationTestCase.test_should_validate_business_rules _____\n\nself = <tests.integration.test_api_endpoints.APIValidationIntegrationTestCase testMethod=test_should_validate_business_rules>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:383: AttributeError\n______ APIValidationIntegrationTestCase.test_should_validate_data_types _______\n\nself = <tests.integration.test_api_endpoints.APIValidationIntegrationTestCase testMethod=test_should_validate_data_types>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:383: AttributeError\n_ APIValidationIntegrationTestCase.test_should_validate_required_fields_on_create _\n\nself = <tests.integration.test_api_endpoints.APIValidationIntegrationTestCase testMethod=test_should_validate_required_fields_on_create>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:383: AttributeError\n_____ APIPaginationIntegrationTestCase.test_should_handle_page_parameters _____\n\nself = <tests.integration.test_api_endpoints.APIPaginationIntegrationTestCase testMethod=test_should_handle_page_parameters>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:447: AttributeError\n___ APIPaginationIntegrationTestCase.test_should_paginate_large_result_sets ___\n\nself = <tests.integration.test_api_endpoints.APIPaginationIntegrationTestCase testMethod=test_should_paginate_large_result_sets>\n\n    def setUp(self):\n        self.user = UserFactory()\n>       self.token = Token.objects.create(user=self.user)\nE       AttributeError: type object 'Token' has no attribute 'objects'\n\ntests\\integration\\test_api_endpoints.py:447: AttributeError\n_ VentasInventarioIntegrationTestCase.test_should_alert_when_inventory_below_minimum _\n\nself = <tests.integration.test_business_flows.VentasInventarioIntegrationTestCase testMethod=test_should_alert_when_inventory_below_minimum>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.proveedor = ProveedorFactory()\n        self.producto = ProductoFactory(\n            proveedor=self.proveedor,\n            tienda=self.tienda,\n            precio=Decimal('100.00')\n        )\n    \n        # Crear inventario inicial\n>       self.inventario = InventarioFactory(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad_actual=10,\n            cantidad_minima=2\n        )\n\ntests\\integration\\test_business_flows.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD00137 - Kane PLC: 10>, args = ()\nkwargs = {'cantidad_minima': 2}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18B43790>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1277>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ VentasInventarioIntegrationTestCase.test_should_prevent_overselling _____\n\nself = <tests.integration.test_business_flows.VentasInventarioIntegrationTestCase testMethod=test_should_prevent_overselling>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.proveedor = ProveedorFactory()\n        self.producto = ProductoFactory(\n            proveedor=self.proveedor,\n            tienda=self.tienda,\n            precio=Decimal('100.00')\n        )\n    \n        # Crear inventario inicial\n>       self.inventario = InventarioFactory(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad_actual=10,\n            cantidad_minima=2\n        )\n\ntests\\integration\\test_business_flows.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD00138 - Jenkins Ltd: 10>, args = ()\nkwargs = {'cantidad_minima': 2}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E4DE70>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1282>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ VentasInventarioIntegrationTestCase.test_should_reduce_inventory_when_order_is_created _\n\nself = <tests.integration.test_business_flows.VentasInventarioIntegrationTestCase testMethod=test_should_reduce_inventory_when_order_is_created>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.proveedor = ProveedorFactory()\n        self.producto = ProductoFactory(\n            proveedor=self.proveedor,\n            tienda=self.tienda,\n            precio=Decimal('100.00')\n        )\n    \n        # Crear inventario inicial\n>       self.inventario = InventarioFactory(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad_actual=10,\n            cantidad_minima=2\n        )\n\ntests\\integration\\test_business_flows.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD00139 - Torres, Evans and Bradford: 10>, args = ()\nkwargs = {'cantidad_minima': 2}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE2200>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1287>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad_minima'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ VentasCajaIntegrationTestCase.test_should_create_cash_transaction_when_order_is_paid _\n\nself = <tests.integration.test_business_flows.VentasCajaIntegrationTestCase testMethod=test_should_create_cash_transaction_when_order_is_paid>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.producto = ProductoFactory(\n            tienda=self.tienda,\n            precio=Decimal('50.00')\n        )\n>       self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\n\ntests\\integration\\test_business_flows.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Caja: Caja Robinson, Hart and Jones - 2025-05-30 19:08:29.337434+00:00>\nargs = (), kwargs = {'turno_activo': True}, cls = <class 'caja.models.Caja'>\nopts = <Options for Caja>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD192B46A0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1292>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ VentasCajaIntegrationTestCase.test_should_handle_partial_payments_with_advances _\n\nself = <tests.integration.test_business_flows.VentasCajaIntegrationTestCase testMethod=test_should_handle_partial_payments_with_advances>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.producto = ProductoFactory(\n            tienda=self.tienda,\n            precio=Decimal('50.00')\n        )\n>       self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\n\ntests\\integration\\test_business_flows.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Caja: Caja Williams, Burton and Olson - 2025-05-30 19:08:29.490767+00:00>\nargs = (), kwargs = {'turno_activo': True}, cls = <class 'caja.models.Caja'>\nopts = <Options for Caja>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE38B0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1297>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ ClientesVentasIntegrationTestCase.test_should_accumulate_customer_purchase_history _\n\nself = <tests.integration.test_business_flows.ClientesVentasIntegrationTestCase testMethod=test_should_accumulate_customer_purchase_history>\n\n    def test_should_accumulate_customer_purchase_history(self):\n        \"\"\"Debe acumular el historial de compras del cliente\"\"\"\n        # Crear m\u00faltiples pedidos\n        pedido1 = PedidoFactory(\n            cliente=self.cliente,\n            tienda=self.tienda,\n            total=Decimal('50.00'),\n            pagado=True\n        )\n    \n        pedido2 = PedidoFactory(\n            cliente=self.cliente,\n            tienda=self.tienda,\n            total=Decimal('75.00'),\n            pagado=True\n        )\n    \n        # Calcular total de compras\n        total_purchases = Pedido.objects.filter(\n            cliente=self.cliente,\n            pagado=True\n>       ).aggregate(total=models.Sum('total'))['total']\nE       NameError: name 'models' is not defined\n\ntests\\integration\\test_business_flows.py:263: NameError\n_ DataConsistencyIntegrationTestCase.test_should_handle_cascade_deletions_properly _\n\nself = <tests.integration.test_business_flows.DataConsistencyIntegrationTestCase testMethod=test_should_handle_cascade_deletions_properly>\n\n    def test_should_handle_cascade_deletions_properly(self):\n        \"\"\"Debe manejar eliminaciones en cascada apropiadamente\"\"\"\n        pedido = PedidoFactory(cliente=self.cliente)\n>       detalle = DetallePedidoFactory(pedido=pedido, producto=self.producto)\n\ntests\\integration\\test_business_flows.py:426: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00144 x 1 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18D7E860>\nval = Decimal('528.855')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00144 - Reebok Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DataConsistencyIntegrationTestCase.test_should_maintain_referential_integrity _\n\nself = <tests.integration.test_business_flows.DataConsistencyIntegrationTestCase testMethod=test_should_maintain_referential_integrity>\n\n    def test_should_maintain_referential_integrity(self):\n        \"\"\"Debe mantener integridad referencial entre modelos\"\"\"\n        # Crear datos relacionados\n        pedido = PedidoFactory(cliente=self.cliente, tienda=self.tienda)\n>       detalle = DetallePedidoFactory(pedido=pedido, producto=self.producto)\n\ntests\\integration\\test_business_flows.py:411: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DetallePedido: PROD00145 x 3 (Pedido 1)>, args = ()\nkwargs = {'descuento_aplicado': Decimal('0.00')}\ncls = <class 'ventas.models.DetallePedido'>, opts = <Options for DetallePedido>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE0D30>\nval = Decimal('2136.555')\nfield = <django.db.models.fields.DecimalField: subtotal>\nis_related_object = False, rel_obj = <Producto: PROD00145 - Reebok Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: DetallePedido() got unexpected keyword arguments: 'descuento_aplicado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n__ DataConsistencyIntegrationTestCase.test_should_prevent_invalid_operations __\n\n    def _execute(self, sql, params, *ignored_wrapper_args):\n        # Raise a warning during app initialization (stored_app_configs is only\n        # ever set during testing).\n        if not apps.ready and not apps.stored_app_configs:\n            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n        self.db.validate_no_broken_transaction()\n        with self.db.wrap_database_errors:\n            if params is None:\n                # params default might be backend specific.\n                return self.cursor.execute(sql)\n            else:\n>               return self.cursor.execute(sql, params)\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def execute(self, query, params=None):\n        if params is None:\n            return super().execute(query)\n        # Extract names if params is a mapping, i.e. \"pyformat\" style is used.\n        param_names = list(params) if isinstance(params, Mapping) else None\n        query = self.convert_query(query, param_names=param_names)\n>       return super().execute(query, params)\nE       sqlite3.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\sqlite3\\base.py:360: IntegrityError\n\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n  File \"C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py\", line 105, in _execute\n    return self.cursor.execute(sql, params)\n           ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^\n  File \"C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\sqlite3\\base.py\", line 360, in execute\n    return super().execute(query, params)\n           ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^\nsqlite3.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nThe above exception was the direct cause of the following exception:\n\ndjango.db.utils.IntegrityError: NOT NULL constraint failed: ventas_pedido.cliente_id\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.integration.test_business_flows.DataConsistencyIntegrationTestCase testMethod=test_should_prevent_invalid_operations>\n\n    def test_should_prevent_invalid_operations(self):\n        \"\"\"Debe prevenir operaciones inv\u00e1lidas\"\"\"\n        # Intentar crear pedido sin cliente deber\u00eda fallar\n        with self.assertRaises(Exception):\n            PedidoFactory(cliente=None, tienda=self.tienda)\n    \n        # Intentar crear detalle sin producto deber\u00eda fallar\n>       pedido = PedidoFactory(cliente=self.cliente, tienda=self.tienda)\n\ntests\\integration\\test_business_flows.py:443: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:270: in build\n    step.resolve(pre)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:211: in resolve\n    self.attributes[field_name] = getattr(self.stub, field_name)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:356: in __getattr__\n    value = value.evaluate_pre(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\declarations.py:67: in evaluate_pre\n    return self.evaluate(instance, step, context)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\declarations.py:457: in evaluate\n    return step.recurse(subfactory, extra, force_sequence=force_sequence)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:228: in recurse\n    return builder.build(parent_step=self, force_sequence=force_sequence)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:663: in create\n    obj.save(force_insert=True, using=self.db)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\contrib\\auth\\base_user.py:65: in save\n    super().save(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:902: in save\n    self.save_base(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1008: in save_base\n    updated = self._save_table(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1169: in _save_table\n    results = self._do_insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:1210: in _do_insert\n    return manager._insert(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:1864: in _insert\n    return query.get_compiler(using=using).execute_sql(returning_fields)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\sql\\compiler.py:1882: in execute_sql\n    cursor.execute(sql, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:79: in execute\n    return self._execute_with_wrappers(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:92: in _execute_with_wrappers\n    return executor(sql, params, many, context)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\utils.py:99: in _execute\n    self.db.validate_no_broken_transaction()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <DatabaseWrapper vendor='sqlite' alias='default'>\n\n    def validate_no_broken_transaction(self):\n        if self.needs_rollback:\n>           raise TransactionManagementError(\n                \"An error occurred in the current transaction. You can't \"\n                \"execute queries until the end of the 'atomic' block.\"\n            ) from self.rollback_exc\nE           django.db.transaction.TransactionManagementError: An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\backends\\base\\base.py:521: TransactionManagementError\n_______ BusinessWorkflowIntegrationTestCase.test_complete_sale_workflow _______\n\nself = <tests.integration.test_business_flows.BusinessWorkflowIntegrationTestCase testMethod=test_complete_sale_workflow>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.proveedor = ProveedorFactory()\n        self.producto = ProductoFactory(\n            proveedor=self.proveedor,\n            tienda=self.tienda,\n            precio=Decimal('100.00')\n        )\n        self.inventario = InventarioFactory(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad_actual=20\n        )\n>       self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\n\ntests\\integration\\test_business_flows.py:287: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Caja: Caja Harmon-Diaz - 2025-05-30 19:08:30.412565+00:00>, args = ()\nkwargs = {'turno_activo': True}, cls = <class 'caja.models.Caja'>\nopts = <Options for Caja>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE3250>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1327>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n__________ BusinessWorkflowIntegrationTestCase.test_return_workflow ___________\n\nself = <tests.integration.test_business_flows.BusinessWorkflowIntegrationTestCase testMethod=test_return_workflow>\n\n    def setUp(self):\n        self.user = UserFactory()\n        self.tienda = TiendaFactory()\n        self.cliente = ClienteFactory(tienda=self.tienda)\n        self.proveedor = ProveedorFactory()\n        self.producto = ProductoFactory(\n            proveedor=self.proveedor,\n            tienda=self.tienda,\n            precio=Decimal('100.00')\n        )\n        self.inventario = InventarioFactory(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad_actual=20\n        )\n>       self.caja = CajaFactory(tienda=self.tienda, turno_activo=True)\n\ntests\\integration\\test_business_flows.py:287: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:43: in __call__\n    return cls.create(**kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:539: in create\n    return cls._generate(enums.CREATE_STRATEGY, kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:122: in _generate\n    return super()._generate(strategy, params)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:468: in _generate\n    return step.build()\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\builder.py:274: in build\n    instance = self.factory_meta.instantiate(\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\base.py:320: in instantiate\n    return self.factory._create(model, *args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:175: in _create\n    return manager.create(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Caja: Caja Baker-Smith - 2025-05-30 19:08:30.646227+00:00>, args = ()\nkwargs = {'turno_activo': True}, cls = <class 'caja.models.Caja'>\nopts = <Options for Caja>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18B846D0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <User: user1333>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Caja() got unexpected keyword arguments: 'turno_activo'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n________ CajaIntegrationTestCase.test_should_complete_daily_cash_cycle ________\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_complete_daily_cash_cycle>\n\n    def test_should_complete_daily_cash_cycle(self):\n        \"\"\"Test ciclo completo diario de caja\"\"\"\n    \n        # 1. Apertura de caja (ya est\u00e1 abierta)\n        self.assertFalse(self.caja.cerrada)\n>       self.assertDecimalEqual(self.caja.saldo_final, Decimal('1000.00'))\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:42: AttributeError\n_______ CajaIntegrationTestCase.test_should_generate_daily_cash_report ________\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_generate_daily_cash_report>\n\n    def test_should_generate_daily_cash_report(self):\n        \"\"\"Test generaci\u00f3n de reporte diario de caja\"\"\"\n    \n        # Registrar diferentes transacciones\n        transacciones_del_dia = []\n    \n        # Ventas\n        for i in range(3):\n            t = TransaccionCaja.objects.create(\n                caja=self.caja,\n                tipo_movimiento='INGRESO',\n                monto=Decimal(f'{100 + i * 50}.00'),\n                descripcion=f'Venta #{i+1}',\n                created_by=self.cajero\n            )\n            transacciones_del_dia.append(t)\n    \n        # Gastos\n        for i in range(2):\n            t = TransaccionCaja.objects.create(\n                caja=self.caja,\n                tipo_movimiento='EGRESO',\n                monto=Decimal(f'{25 + i * 15}.00'),\n                descripcion=f'Gasto #{i+1}',\n                created_by=self.cajero\n            )\n            transacciones_del_dia.append(t)\n    \n        # Calcular totales\n        total_ingresos = sum(\n            t.monto for t in transacciones_del_dia\n            if t.tipo_movimiento == 'INGRESO'\n        )\n        total_egresos = sum(\n            t.monto for t in transacciones_del_dia\n            if t.tipo_movimiento == 'EGRESO'\n        )\n    \n        # Actualizar caja\n        self.caja.ingresos = total_ingresos\n        self.caja.egresos = total_egresos\n        self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos - self.caja.egresos\n        self.caja.save()\n    \n        # Generar reporte\n        reporte = {\n            'fecha': self.caja.fecha,\n            'fondo_inicial': self.caja.fondo_inicial,\n            'total_ingresos': total_ingresos,\n            'total_egresos': total_egresos,\n            'saldo_final': self.caja.saldo_final,\n            'num_transacciones': len(transacciones_del_dia)\n        }\n    \n        # Verificar reporte\n>       self.assertDecimalEqual(reporte['total_ingresos'], Decimal('450.00'))  # 100+150+200\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:444: AttributeError\n_______ CajaIntegrationTestCase.test_should_generate_invoices_workflow ________\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_generate_invoices_workflow>\n\n    def test_should_generate_invoices_workflow(self):\n        \"\"\"Test flujo de generaci\u00f3n de facturas\"\"\"\n    \n        # 1. Crear venta que requiere factura\n        pedido = Pedido.objects.create(\n            tienda=self.tienda,\n            cliente=self.cliente,\n            fecha=timezone.now().date(),\n            total=Decimal('1000.00'),\n            estado='confirmado',\n            created_by=self.cajero\n        )\n    \n        # 2. Registrar venta en caja\n        transaccion_venta = TransaccionCaja.objects.create(\n            caja=self.caja,\n            tipo_movimiento='INGRESO',\n            monto=pedido.total,\n            descripcion=f'Venta pedido {pedido.id}',\n            pedido=pedido,\n            created_by=self.cajero\n        )\n    \n        # 3. Generar factura\n>       factura = Factura.objects.create(\n            pedido=pedido,\n            numero='F001-001',\n            fecha=timezone.now().date(),\n            subtotal=Decimal('862.07'),  # 1000 / 1.16\n            iva=Decimal('137.93'),       # 1000 - 862.07\n            total=pedido.total,\n            created_by=self.cajero\n        )\n\ntests\\integration\\test_cash_operations.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Factura: Factura  - Pedido 1>, args = ()\nkwargs = {'iva': Decimal('137.93'), 'numero': 'F001-001', 'subtotal': Decimal('862.07')}\ncls = <class 'caja.models.Factura'>, opts = <Options for Factura>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD19574760>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = True, rel_obj = <User: cajero>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Factura() got unexpected keyword arguments: 'numero', 'subtotal', 'iva'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n______ CajaIntegrationTestCase.test_should_handle_cash_advances_workflow ______\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_handle_cash_advances_workflow>\n\n    def test_should_handle_cash_advances_workflow(self):\n        \"\"\"Test flujo completo de anticipos\"\"\"\n    \n        # 1. Cliente solicita anticipo\n>       anticipo = Anticipo.objects.create(\n            cliente=self.cliente,\n            tienda=self.tienda,\n            monto=Decimal('500.00'),\n            fecha=timezone.now().date(),\n            estado='pendiente',\n            created_by=self.cajero\n        )\n\ntests\\integration\\test_cash_operations.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Anticipo: Anticipo 500.00 - Emily Wong>, args = ()\nkwargs = {'estado': 'pendiente', 'tienda': <Tienda: Tienda Integraci\u00f3n>}\ncls = <class 'clientes.models.Anticipo'>, opts = <Options for Anticipo>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD194A72E0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: created_by>\nis_related_object = True, rel_obj = <User: cajero>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Anticipo() got unexpected keyword arguments: 'tienda', 'estado'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n________ CajaIntegrationTestCase.test_should_handle_cash_discrepancies ________\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_handle_cash_discrepancies>\n\n    def test_should_handle_cash_discrepancies(self):\n        \"\"\"Test manejo de diferencias en caja\"\"\"\n    \n        # Simular ventas registradas\n        total_ventas = Decimal('800.00')\n        self.caja.ingresos = total_ventas\n        self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos\n        self.caja.save()\n    \n        # Conteo f\u00edsico de caja\n        conteo_fisico = Decimal('1750.00')  # Faltante de 50.00\n        diferencia = conteo_fisico - self.caja.saldo_final\n    \n        if diferencia != 0:\n            # Crear nota de cargo por la diferencia\n            if diferencia < 0:\n                nota_cargo = NotaCargo.objects.create(\n                    caja=self.caja,\n                    monto=abs(diferencia),\n                    motivo='Faltante en conteo f\u00edsico',\n                    fecha=timezone.now().date(),\n                    created_by=self.cajero\n                )\n    \n                # Registrar en transacciones\n                TransaccionCaja.objects.create(\n                    caja=self.caja,\n                    tipo_movimiento='EGRESO',\n                    monto=abs(diferencia),\n                    descripcion='Ajuste por faltante en caja',\n                    nota_cargo=nota_cargo,\n                    created_by=self.cajero\n                )\n    \n                # Actualizar saldo\n                self.caja.egresos += abs(diferencia)\n            else:\n                # Sobrante - registrar como ingreso\n                TransaccionCaja.objects.create(\n                    caja=self.caja,\n                    tipo_movimiento='INGRESO',\n                    monto=diferencia,\n                    descripcion='Ajuste por sobrante en caja',\n                    created_by=self.cajero\n                )\n    \n                self.caja.ingresos += diferencia\n    \n            # Actualizar saldo final\n            self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos - self.caja.egresos\n            self.caja.save()\n    \n        # Verificar ajuste\n>       self.assertDecimalEqual(self.caja.saldo_final, conteo_fisico)\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:288: AttributeError\n___ CajaIntegrationTestCase.test_should_handle_cash_transfers_between_boxes ___\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_handle_cash_transfers_between_boxes>\n\n    def test_should_handle_cash_transfers_between_boxes(self):\n        \"\"\"Test transferencias entre cajas\"\"\"\n    \n        # Crear segunda caja\n        caja2 = CajaFactory(\n            tienda=self.tienda,\n            fecha=timezone.now().date(),\n            fondo_inicial=Decimal('500.00'),\n            saldo_final=Decimal('500.00')\n        )\n    \n        # Transferencia de caja1 a caja2\n        monto_transferencia = Decimal('200.00')\n    \n        # Egreso de caja origen\n        egreso = TransaccionCaja.objects.create(\n            caja=self.caja,\n            tipo_movimiento='EGRESO',\n            monto=monto_transferencia,\n            descripcion=f'Transferencia a caja {caja2.id}',\n            referencia=f'TRANSFER_TO_{caja2.id}',\n            created_by=self.cajero\n        )\n    \n        # Ingreso en caja destino\n        ingreso = TransaccionCaja.objects.create(\n            caja=caja2,\n            tipo_movimiento='INGRESO',\n            monto=monto_transferencia,\n            descripcion=f'Transferencia desde caja {self.caja.id}',\n            referencia=f'TRANSFER_FROM_{self.caja.id}',\n            created_by=self.cajero\n        )\n    \n        # Actualizar saldos\n        self.caja.egresos += monto_transferencia\n        self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos - self.caja.egresos\n        self.caja.save()\n    \n        caja2.ingresos += monto_transferencia\n        caja2.saldo_final = caja2.fondo_inicial + caja2.ingresos - caja2.egresos\n        caja2.save()\n    \n        # Verificar transferencia\n>       self.assertDecimalEqual(self.caja.saldo_final, Decimal('800.00'))  # 1000 - 200\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:382: AttributeError\n______ CajaIntegrationTestCase.test_should_handle_charge_notes_workflow _______\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_handle_charge_notes_workflow>\n\n    def test_should_handle_charge_notes_workflow(self):\n        \"\"\"Test flujo de notas de cargo\"\"\"\n    \n        # 1. Crear nota de cargo por faltante\n        nota_cargo = NotaCargo.objects.create(\n            caja=self.caja,\n            monto=Decimal('25.00'),\n            motivo='Faltante en caja al cierre',\n            fecha=timezone.now().date(),\n            created_by=self.cajero\n        )\n    \n        # 2. Registrar nota de cargo en transacciones\n        transaccion_cargo = TransaccionCaja.objects.create(\n            caja=self.caja,\n            tipo_movimiento='EGRESO',\n            monto=nota_cargo.monto,\n            descripcion=f'Nota de cargo: {nota_cargo.motivo}',\n            nota_cargo=nota_cargo,\n            created_by=self.cajero\n        )\n    \n        # 3. Actualizar caja\n        self.caja.egresos += nota_cargo.monto\n        self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos - self.caja.egresos\n        self.caja.save()\n    \n        # Verificar nota de cargo\n        saldo_esperado = Decimal('1000.00') - Decimal('25.00')\n>       self.assertDecimalEqual(self.caja.saldo_final, saldo_esperado)\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:188: AttributeError\n_____ CajaIntegrationTestCase.test_should_track_multiple_payment_methods ______\n\nself = <tests.integration.test_cash_operations.CajaIntegrationTestCase testMethod=test_should_track_multiple_payment_methods>\n\n    def test_should_track_multiple_payment_methods(self):\n        \"\"\"Test seguimiento de m\u00faltiples m\u00e9todos de pago\"\"\"\n    \n        # Venta con pago mixto\n        pedido = Pedido.objects.create(\n            tienda=self.tienda,\n            cliente=self.cliente,\n            fecha=timezone.now().date(),\n            total=Decimal('500.00'),\n            estado='confirmado',\n            created_by=self.cajero\n        )\n    \n        # Pago en efectivo\n        pago_efectivo = TransaccionCaja.objects.create(\n            caja=self.caja,\n            tipo_movimiento='INGRESO',\n            monto=Decimal('300.00'),\n            descripcion='Pago efectivo pedido {}'.format(pedido.id),\n            referencia='EFECTIVO',\n            pedido=pedido,\n            created_by=self.cajero\n        )\n    \n        # Pago con tarjeta (no afecta caja f\u00edsica)\n        pago_tarjeta = TransaccionCaja.objects.create(\n            caja=self.caja,\n            tipo_movimiento='INGRESO',\n            monto=Decimal('200.00'),\n            descripcion='Pago tarjeta pedido {}'.format(pedido.id),\n            referencia='TARJETA',\n            pedido=pedido,\n            created_by=self.cajero\n        )\n    \n        # Actualizar solo efectivo en caja f\u00edsica\n        self.caja.ingresos += pago_efectivo.monto  # Solo efectivo\n        self.caja.saldo_final = self.caja.fondo_inicial + self.caja.ingresos - self.caja.egresos\n        self.caja.save()\n    \n        # Verificar transacciones\n        transacciones_pedido = TransaccionCaja.objects.filter(pedido=pedido)\n        total_transacciones = sum(t.monto for t in transacciones_pedido)\n    \n        self.assertEqual(transacciones_pedido.count(), 2)\n>       self.assertDecimalEqual(total_transacciones, pedido.total)\nE       AttributeError: 'CajaIntegrationTestCase' object has no attribute 'assertDecimalEqual'. Did you mean: 'assertDictEqual'?\n\ntests\\integration\\test_cash_operations.py:335: AttributeError\n_ DevolucionesIntegrationTestCase.test_should_complete_customer_return_workflow _\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_complete_customer_return_workflow>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AC4D4B0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Adidas Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DevolucionesIntegrationTestCase.test_should_complete_exchange_return_workflow _\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_complete_exchange_return_workflow>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18B434F0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Reebok Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ DevolucionesIntegrationTestCase.test_should_handle_partial_returns ______\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_handle_partial_returns>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD194A7AC0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Puma Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DevolucionesIntegrationTestCase.test_should_handle_supplier_return_workflow _\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_handle_supplier_return_workflow>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1A8F17E0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Nike Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ DevolucionesIntegrationTestCase.test_should_integrate_returns_with_loyalty_program _\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_integrate_returns_with_loyalty_program>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1B156770>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Puma Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ DevolucionesIntegrationTestCase.test_should_track_return_statistics _____\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_track_return_statistics>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AE16860>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Converse Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n____ DevolucionesIntegrationTestCase.test_should_validate_return_timeframe ____\n\nself = <tests.integration.test_return_workflows.DevolucionesIntegrationTestCase testMethod=test_should_validate_return_timeframe>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Proveedor\n        self.proveedor = ProveedorFactory()\n    \n        # Productos\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00'),\n            proveedor=self.proveedor\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00'),\n            proveedor=self.proveedor\n        )\n    \n        # Inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_return_workflows.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AE153C0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Converse Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_______ VentasIntegrationTestCase.test_should_calculate_complex_pricing _______\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_calculate_complex_pricing>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1C68B310>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Reebok Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ VentasIntegrationTestCase.test_should_complete_full_sales_workflow ______\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_complete_full_sales_workflow>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1B028F40>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Adidas Running>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ VentasIntegrationTestCase.test_should_handle_insufficient_inventory _____\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_handle_insufficient_inventory>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AFE3370>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Adidas Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_______ VentasIntegrationTestCase.test_should_handle_partial_deliveries _______\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_handle_partial_deliveries>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1A852FB0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Puma Casual>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_______ VentasIntegrationTestCase.test_should_handle_sales_cancellation _______\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_handle_sales_cancellation>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AB36950>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Adidas Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ VentasIntegrationTestCase.test_should_integrate_with_cash_register ______\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_integrate_with_cash_register>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AB371F0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Puma Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_________ VentasIntegrationTestCase.test_should_track_sales_by_period _________\n\nself = <tests.integration.test_sales_workflows.VentasIntegrationTestCase testMethod=test_should_track_sales_by_period>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear productos con inventario\n        self.producto1 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001',\n            precio=Decimal('100.00')\n        )\n        self.producto2 = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD002',\n            precio=Decimal('200.00')\n        )\n    \n        # Crear inventarios\n>       self.inventario1 = Inventario.objects.create(\n            producto=self.producto1,\n            tienda=self.tienda,\n            cantidad=50\n        )\n\ntests\\integration\\test_sales_workflows.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 50}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18E4CC40>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Reebok Classic>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_ InventarioIntegrationTestCase.test_should_complete_inventory_transfer_workflow _\n\nself = <tests.integration.test_sales_workflows.InventarioIntegrationTestCase testMethod=test_should_complete_inventory_transfer_workflow>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear segunda tienda para traspasos\n        self.tienda_destino = TiendaFactory(nombre='Tienda Destino')\n    \n        # Productos\n        self.producto = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001'\n        )\n    \n        # Inventarios en ambas tiendas\n>       self.inventario_origen = Inventario.objects.create(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad=100\n        )\n\ntests\\integration\\test_sales_workflows.py:419: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 100}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD18EE01F0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Nike Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n____ InventarioIntegrationTestCase.test_should_prevent_negative_inventory _____\n\nself = <tests.integration.test_sales_workflows.InventarioIntegrationTestCase testMethod=test_should_prevent_negative_inventory>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear segunda tienda para traspasos\n        self.tienda_destino = TiendaFactory(nombre='Tienda Destino')\n    \n        # Productos\n        self.producto = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001'\n        )\n    \n        # Inventarios en ambas tiendas\n>       self.inventario_origen = Inventario.objects.create(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad=100\n        )\n\ntests\\integration\\test_sales_workflows.py:419: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 100}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AC4C4C0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Puma Formal>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n_____ InventarioIntegrationTestCase.test_should_track_inventory_movements _____\n\nself = <tests.integration.test_sales_workflows.InventarioIntegrationTestCase testMethod=test_should_track_inventory_movements>\n\n    def setUp(self):\n        super().setUp()\n    \n        # Crear segunda tienda para traspasos\n        self.tienda_destino = TiendaFactory(nombre='Tienda Destino')\n    \n        # Productos\n        self.producto = ProductoFactory(\n            tienda=self.tienda,\n            codigo='PROD001'\n        )\n    \n        # Inventarios en ambas tiendas\n>       self.inventario_origen = Inventario.objects.create(\n            producto=self.producto,\n            tienda=self.tienda,\n            cantidad=100\n        )\n\ntests\\integration\\test_sales_workflows.py:419: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\manager.py:87: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\query.py:661: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Inventario: PROD001 - Tienda Integraci\u00f3n: 0>, args = ()\nkwargs = {'cantidad': 100}, cls = <class 'inventario.models.Inventario'>\nopts = <Options for Inventario>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000002AD1AC4C4C0>, val = None\nfield = <django.db.models.fields.related.ForeignKey: updated_by>\nis_related_object = False, rel_obj = <Producto: PROD001 - Nike Sport>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError(\"Abstract models cannot be instantiated.\")\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:\n                    raise TypeError(\n                        f\"{cls.__qualname__}() got both positional and \"\n                        f\"keyword arguments for field '{field.name}'.\"\n                    )\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.column is None or field.generated:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            unexpected = ()\n            for prop, value in kwargs.items():\n                # Any remaining kwargs must correspond to properties or virtual\n                # fields.\n                if prop in property_names:\n                    if value is not _DEFERRED:\n                        _setattr(self, prop, value)\n                else:\n                    try:\n                        opts.get_field(prop)\n                    except FieldDoesNotExist:\n                        unexpected += (prop,)\n                    else:\n                        if value is not _DEFERRED:\n                            _setattr(self, prop, value)\n            if unexpected:\n                unexpected_names = \", \".join(repr(n) for n in unexpected)\n>               raise TypeError(\n                    f\"{cls.__name__}() got unexpected keyword arguments: \"\n                    f\"{unexpected_names}\"\n                )\nE               TypeError: Inventario() got unexpected keyword arguments: 'cantidad'\n\nC:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\base.py:569: TypeError\n============================== warnings summary ===============================\ntests/unit/test_administracion_models.py: 27 warnings\ntests/unit/test_descuentos_models.py: 18 warnings\ntests/unit/test_devoluciones_models.py: 28 warnings\ntests/unit/test_productos_models.py: 28 warnings\ntests/unit/test_proveedores_models.py: 29 warnings\ntests/unit/test_tiendas_models.py: 22 warnings\ntests/integration/test_cash_operations.py: 8 warnings\ntests/integration/test_return_workflows.py: 7 warnings\ntests/integration/test_sales_workflows.py: 10 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: AdminUserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the AdminUserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py: 88 warnings\ntests/unit/test_caja_models.py: 110 warnings\ntests/unit/test_clientes_models.py: 76 warnings\ntests/unit/test_descuentos_models.py: 36 warnings\ntests/unit/test_devoluciones_models.py: 193 warnings\ntests/unit/test_inventario_models.py: 132 warnings\ntests/unit/test_productos_models.py: 127 warnings\ntests/unit/test_proveedores_models.py: 143 warnings\ntests/unit/test_tiendas_models.py: 51 warnings\ntests/unit/test_ventas_models.py: 141 warnings\ntests/integration/test_api_endpoints.py: 24 warnings\ntests/integration/test_business_flows.py: 60 warnings\ntests/integration/test_cash_operations.py: 25 warnings\ntests/integration/test_return_workflows.py: 28 warnings\ntests/integration/test_sales_workflows.py: 44 warnings\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\factory\\django.py:182: DeprecationWarning: UserFactory._after_postgeneration will stop saving the instance after postgeneration hooks in the next major release.\n  If the save call is extraneous, set skip_postgeneration_save=True in the UserFactory.Meta.\n  To keep saving the instance, move the save call to your postgeneration hooks or override _after_postgeneration.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_handle_cuenta_bloqueada_scenarios\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField PerfilUsuario.fecha_bloqueo received a naive datetime (2025-05-30 13:08:20.478575) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_track_ultimo_acceso\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField PerfilUsuario.fecha_ultimo_acceso received a naive datetime (2025-05-29 16:30:00) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_track_temporal_changes\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField ConfiguracionSistema.fecha_modificacion received a naive datetime (2025-05-29 10:00:00) while time zone support is active.\n    warnings.warn(\n\ntests/unit/test_administracion_models.py::AdministracionModelsIntegrationTests::test_should_track_temporal_changes\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1671: RuntimeWarning: DateTimeField ConfiguracionSistema.fecha_modificacion received a naive datetime (2025-05-29 12:00:00) while time zone support is active.\n    warnings.warn(\n\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_invoices_workflow\ntests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_track_multiple_payment_methods\n  C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\django\\db\\models\\fields\\__init__.py:1612: RuntimeWarning: DateTimeField Pedido.fecha received a naive datetime (2025-05-30 00:00:00) while time zone support is active.\n    warnings.warn(\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n=========================== short test summary info ===========================\nFAILED tests/unit/test_administracion_models.py::PerfilUsuarioModelTests::test_should_create_perfil_usuario_with_valid_data\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_onetoone_relationship_with_pedido\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_enforce_unique_folio_when_creating_duplicate\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_handle_created_by_field_when_user_provided\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_have_correct_string_representation_when_created\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_protect_pedido_when_factura_exists\nFAILED tests/unit/test_caja_models.py::FacturaModelTestCase::test_should_relate_to_pedido_correctly_through_onetoone\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_calculate_saldo_final_correctly_when_movements_processed\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_handle_factura_generation_workflow_when_pedido_completed\nFAILED tests/unit/test_caja_models.py::CajaBusinessLogicTestCase::test_should_prevent_duplicate_facturas_when_pedido_already_has_one\nFAILED tests/unit/test_devoluciones_models.py::TestDevolucionModel::test_should_handle_null_detalle_pedido_on_deletion\nFAILED tests/unit/test_devoluciones_models.py::TestDevolucionModel::test_should_link_to_detalle_pedido_optionally\nFAILED tests/unit/test_devoluciones_models.py::TestDevolucionWorkflow::test_should_process_defect_return_workflow\nFAILED tests/unit/test_devoluciones_models.py::TestDevolucionIntegration::test_should_link_devolucion_to_original_sale\nFAILED tests/unit/test_inventario_models.py::TraspasoModelTestCase::test_should_auto_set_fecha_when_created\nFAILED tests/unit/test_inventario_models.py::TraspasoItemModelTestCase::test_should_enforce_positive_cantidad_when_creating\nFAILED tests/unit/test_proveedores_models.py::TestPurchaseOrderItemModel::test_should_validate_positive_quantities\nFAILED tests/unit/test_tiendas_models.py::TestTiendaIntegration::test_should_handle_tienda_name_searches\nFAILED tests/unit/test_tiendas_models.py::TestTiendaIntegration::test_should_preserve_tienda_hierarchy\nFAILED tests/unit/test_tiendas_models.py::TestTiendaIntegration::test_should_support_geographical_organization\nFAILED tests/unit/test_tiendas_models.py::TestTiendaIntegration::test_should_support_multi_store_operations\nFAILED tests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_convert_to_venta_when_completed\nFAILED tests/unit/test_ventas_models.py::PedidoModelTestCase::test_should_validate_decimal_fields_precision_when_creating\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_calculate_subtotal_correctly_when_business_logic_applied\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_enforce_positive_cantidad_when_creating\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_handle_multiple_detalles_per_pedido_when_different_products\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_have_correct_string_representation_when_created\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_maintain_referential_integrity_when_pedido_deleted\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_protect_producto_when_detalle_exists\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_pedido_correctly_through_foreign_key\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_relate_to_producto_correctly_through_foreign_key\nFAILED tests/unit/test_ventas_models.py::DetallePedidoModelTestCase::test_should_validate_decimal_precision_when_creating_detalle\nFAILED tests/unit/test_ventas_models.py::PedidoBusinessLogicTestCase::test_should_update_porcentaje_completado_when_method_called\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_create_producto_via_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_list_productos_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_search_productos_api\nFAILED tests/integration/test_api_endpoints.py::ProductosAPIIntegrationTestCase::test_should_update_producto_via_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_create_pedido_via_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_list_pedidos_api\nFAILED tests/integration/test_api_endpoints.py::VentasAPIIntegrationTestCase::test_should_process_payment_via_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_create_cliente_via_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_get_cliente_purchase_history_api\nFAILED tests/integration/test_api_endpoints.py::ClientesAPIIntegrationTestCase::test_should_list_clientes_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_get_low_stock_alert_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_list_inventario_api\nFAILED tests/integration/test_api_endpoints.py::InventarioAPIIntegrationTestCase::test_should_update_stock_via_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_close_caja_via_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_get_caja_summary_api\nFAILED tests/integration/test_api_endpoints.py::CajaAPIIntegrationTestCase::test_should_open_caja_via_api\nFAILED tests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_authenticate_with_token\nFAILED tests/integration/test_api_endpoints.py::AuthenticationAPIIntegrationTestCase::test_should_handle_invalid_token\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_business_rules\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_data_types\nFAILED tests/integration/test_api_endpoints.py::APIValidationIntegrationTestCase::test_should_validate_required_fields_on_create\nFAILED tests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_handle_page_parameters\nFAILED tests/integration/test_api_endpoints.py::APIPaginationIntegrationTestCase::test_should_paginate_large_result_sets\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_alert_when_inventory_below_minimum\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_prevent_overselling\nFAILED tests/integration/test_business_flows.py::VentasInventarioIntegrationTestCase::test_should_reduce_inventory_when_order_is_created\nFAILED tests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_create_cash_transaction_when_order_is_paid\nFAILED tests/integration/test_business_flows.py::VentasCajaIntegrationTestCase::test_should_handle_partial_payments_with_advances\nFAILED tests/integration/test_business_flows.py::ClientesVentasIntegrationTestCase::test_should_accumulate_customer_purchase_history\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_handle_cascade_deletions_properly\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_maintain_referential_integrity\nFAILED tests/integration/test_business_flows.py::DataConsistencyIntegrationTestCase::test_should_prevent_invalid_operations\nFAILED tests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_complete_sale_workflow\nFAILED tests/integration/test_business_flows.py::BusinessWorkflowIntegrationTestCase::test_return_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_complete_daily_cash_cycle\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_daily_cash_report\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_generate_invoices_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_advances_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_discrepancies\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_cash_transfers_between_boxes\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_handle_charge_notes_workflow\nFAILED tests/integration/test_cash_operations.py::CajaIntegrationTestCase::test_should_track_multiple_payment_methods\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_customer_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_complete_exchange_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_partial_returns\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_handle_supplier_return_workflow\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_integrate_returns_with_loyalty_program\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_track_return_statistics\nFAILED tests/integration/test_return_workflows.py::DevolucionesIntegrationTestCase::test_should_validate_return_timeframe\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_calculate_complex_pricing\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_complete_full_sales_workflow\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_insufficient_inventory\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_partial_deliveries\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_handle_sales_cancellation\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_integrate_with_cash_register\nFAILED tests/integration/test_sales_workflows.py::VentasIntegrationTestCase::test_should_track_sales_by_period\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_complete_inventory_transfer_workflow\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_prevent_negative_inventory\nFAILED tests/integration/test_sales_workflows.py::InventarioIntegrationTestCase::test_should_track_inventory_movements\n=============== 92 failed, 260 passed, 1461 warnings in 20.84s ================\n",
      "stderr": ""
    },
    {
      "command": "coverage report",
      "description": "Coverage Report - Console",
      "returncode": 1,
      "execution_time": 0.42200350761413574,
      "stdout": "Couldn't parse 'C:\\catalog_pos\\caja\\test_api_complete.py' as Python source: 'unindent does not match any outer indentation level' at line 255\n",
      "stderr": ""
    },
    {
      "command": "coverage html",
      "description": "Coverage Report - HTML Generation",
      "returncode": 1,
      "execution_time": 0.40068602561950684,
      "stdout": "Couldn't parse 'C:\\catalog_pos\\caja\\test_api_complete.py' as Python source: 'unindent does not match any outer indentation level' at line 255\n",
      "stderr": ""
    },
    {
      "command": "python -m flake8 --max-line-length=120 --exclude=migrations,venv,env .",
      "description": "Code Quality - Flake8",
      "returncode": 1,
      "execution_time": 0.08358311653137207,
      "stdout": "",
      "stderr": "C:\\Users\\Arenso07\\AppData\\Local\\Programs\\Python\\Python313\\python.exe: No module named flake8\n"
    }
  ]
}